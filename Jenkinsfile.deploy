// Enhanced Jenkinsfile.deploy - Production Deployment Pipeline
// This pipeline manages production deployments and 'latest' tag updates

pipeline {
    agent any
    
    parameters {
        booleanParam(
            name: 'CONFIRM_DEPLOYMENT',
            defaultValue: false,
            description: 'Check this box to confirm production deployment'
        )
        booleanParam(
            name: 'UPDATE_LATEST_TAGS',
            defaultValue: true,
            description: 'Update the "latest" tags to point to production versions'
        )
        booleanParam(
            name: 'RUN_HEALTH_CHECKS',
            defaultValue: true,
            description: 'Run health checks after deployment'
        )
        booleanParam(
            name: 'ROLLBACK_ON_FAILURE',
            defaultValue: true,
            description: 'Automatically rollback on deployment failure'
        )
        string(
            name: 'SLACK_WEBHOOK_URL',
            defaultValue: '',
            description: 'Slack webhook URL for deployment notifications'
        )
    }
    
    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
    }
    
    environment {
        // These will be loaded from deployment-versions.yaml config section
        DOCKER_REGISTRY = ''
        DOCKER_REPO = ''
        DOCKER_LATEST_PATH = ''
        ARTIFACTORY_CREDS = credentials('artifactory-credentials')
        
        // Track rollback state
        ROLLBACK_REQUIRED = 'false'
        PREVIOUS_VERSIONS = ''
    }
    
    // NO TRIGGERS - This pipeline is manual only
    
    stages {
        // ================================================================================
        // STAGE 1: Pre-flight Checks
        // ================================================================================
        stage('Pre-flight Checks') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> PRODUCTION DEPLOYMENT PIPELINE"
                    echo "========================================="
                    
                    if (!params.CONFIRM_DEPLOYMENT) {
                        error("âŒ Deployment not confirmed. Please check 'CONFIRM_DEPLOYMENT' to proceed.")
                    }
                    
                    echo "âœ… Deployment confirmed by user"
                    echo "Build Number: ${env.BUILD_NUMBER}"
                    echo "Triggered by: ${env.BUILD_USER ?: 'Jenkins'}"
                    echo "Update Latest Tags: ${params.UPDATE_LATEST_TAGS}"
                    echo "Run Health Checks: ${params.RUN_HEALTH_CHECKS}"
                    echo "Rollback on Failure: ${params.ROLLBACK_ON_FAILURE}"
                    echo "========================================="
                }
            }
        }
        
        // ================================================================================
        // STAGE 2: Checkout and Validate
        // ================================================================================
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Get current branch
                    env.GIT_BRANCH_NAME = bat(
                        script: '@git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    
                    // Only allow deployment from main/master branch
                    if (env.GIT_BRANCH_NAME != 'main' && env.GIT_BRANCH_NAME != 'master') {
                        error("âŒ Deployment only allowed from main/master branch. Current branch: ${env.GIT_BRANCH_NAME}")
                    }
                    
                    // Get git commit info
                    env.GIT_COMMIT_HASH = bat(
                        script: '@git rev-parse HEAD',
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_COMMIT_SHORT = bat(
                        script: '@git rev-parse --short=8 HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "âœ… On ${env.GIT_BRANCH_NAME} branch"
                    echo "ðŸ“ Commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        // ================================================================================
        // STAGE 3: Read and Validate Configuration
        // ================================================================================
        stage('Read Configuration') {
            steps {
                script {
                    echo "ðŸ“– Reading deployment-versions.yaml..."
                    
                    if (!fileExists('deployment-versions.yaml')) {
                        error("âŒ deployment-versions.yaml not found in repository root")
                    }
                    
                    // Read the YAML file
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    
                    // Validate structure
                    if (!deployConfig.production || deployConfig.production.size() == 0) {
                        error("âŒ No production versions defined in deployment-versions.yaml")
                    }
                    
                    if (!deployConfig.config) {
                        error("âŒ Config section missing in deployment-versions.yaml")
                    }
                    
                    // Load config values into environment
                    env.DOCKER_REGISTRY = deployConfig.config.docker_registry
                    env.DOCKER_REPO = deployConfig.config.docker_repo
                    env.DOCKER_LATEST_PATH = deployConfig.config.docker_latest_path
                    env.BUILD_MANIFESTS_PATH = deployConfig.config.build_manifests_path
                    
                    echo "\n>>> Configuration loaded:"
                    echo "  Registry: ${env.DOCKER_REGISTRY}"
                    echo "  Repository: ${env.DOCKER_REPO}"
                    echo "  Path: ${env.DOCKER_LATEST_PATH}"
                    
                    echo "\n>>> Applications to deploy:"
                    deployConfig.production.each { app, version ->
                        // Validate version format
                        if (!version.matches('^\\d+\\.\\d+\\.\\d+$')) {
                            error("âŒ Invalid version format for ${app}: ${version} (expected: X.Y.Z)")
                        }
                        env["VERSION_${app.toUpperCase().replace('-', '_')}"] = version
                        echo "  ${app}: ${version}"
                    }
                    
                    // Store for later stages
                    env.DEPLOY_CONFIG_JSON = groovy.json.JsonOutput.toJson(deployConfig.production)
                }
            }
        }
        
        // ================================================================================
        // STAGE 4: Backup Current Latest Tags
        // ================================================================================
        stage('Backup Current State') {
            when {
                expression { params.ROLLBACK_ON_FAILURE == true }
            }
            steps {
                script {
                    echo "ðŸ’¾ Backing up current 'latest' tags for potential rollback..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def backupInfo = [:]
                    
                    deployConfig.production.each { app, version ->
                        echo "\n  Checking current latest for ${app}..."
                        
                        // Get current latest tag manifest
                        def manifestUrl = "https://${env.DOCKER_REGISTRY}/artifactory/api/docker/${env.DOCKER_REPO}/v2/${env.DOCKER_LATEST_PATH}/${app}/manifests/latest"
                        
                        def response = bat(
                            script: """
                                @curl -s -u %ARTIFACTORY_CREDS_USR%:%ARTIFACTORY_CREDS_PSW% ^
                                     -X GET "${manifestUrl}" ^
                                     -H "Accept: application/vnd.docker.distribution.manifest.v2+json"
                            """,
                            returnStdout: true
                        ).trim()
                        
                        // Extract config digest to identify the actual version
                        if (response.contains('"config"')) {
                            def configMatch = response =~ /"config":\s*\{[^}]*"digest":\s*"([^"]+)"/
                            if (configMatch) {
                                backupInfo[app] = [
                                    digest: configMatch[0][1],
                                    newVersion: version
                                ]
                                echo "    Current latest digest: ${configMatch[0][1]}"
                            }
                        }
                    }
                    
                    // Store backup info
                    env.PREVIOUS_VERSIONS = groovy.json.JsonOutput.toJson(backupInfo)
                    
                    // Write backup file
                    def backupFile = "deployment-backup-${env.BUILD_NUMBER}.json"
                    writeFile file: backupFile, text: groovy.json.JsonOutput.prettyPrint(env.PREVIOUS_VERSIONS)
                    archiveArtifacts artifacts: backupFile, fingerprint: true
                    
                    echo "\nâœ… Backup completed and archived"
                }
            }
        }
        
        // ================================================================================
        // STAGE 5: Verify Images Exist
        // ================================================================================
        stage('Verify Images') {
            steps {
                script {
                    echo "ðŸ” Verifying all production images exist in Artifactory..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def missingImages = []
                    def foundImages = []
                    def imageManifests = [:]
                    
                    deployConfig.production.each { app, version ->
                        echo "\n  Checking ${app}:${version}..."
                        
                        // Check if image exists and get its manifest
                        def checkUrl = "https://${env.DOCKER_REGISTRY}/artifactory/api/docker/${env.DOCKER_REPO}/v2/${env.DOCKER_LATEST_PATH}/${app}/manifests/${version}"
                        
                        def response = bat(
                            script: """
                                @curl -s -u %ARTIFACTORY_CREDS_USR%:%ARTIFACTORY_CREDS_PSW% ^
                                     -X GET "${checkUrl}" ^
                                     -w "\\nHTTPSTATUS:%%{http_code}"
                            """,
                            returnStdout: true
                        ).trim()
                        
                        def httpStatus = response.contains('HTTPSTATUS:') ? 
                            response.split('HTTPSTATUS:')[1] : '000'
                        
                        if (httpStatus == "200") {
                            echo "    âœ… Found: ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:${version}"
                            foundImages.add("${app}:${version}")
                            
                            // Extract and verify image labels
                            if (response.contains('"config"')) {
                                def configMatch = response =~ /"config":\s*\{[^}]*"digest":\s*"([^"]+)"/
                                if (configMatch) {
                                    imageManifests[app] = configMatch[0][1]
                                    echo "    ðŸ“‹ Manifest digest: ${configMatch[0][1]}"
                                }
                            }
                        } else {
                            echo "    âŒ NOT FOUND: ${app}:${version} (HTTP ${httpStatus})"
                            missingImages.add("${app}:${version}")
                        }
                    }
                    
                    if (missingImages.size() > 0) {
                        error("""
                        âŒ Missing images in Artifactory:
                        ${missingImages.join('\n')}
                        
                        Please ensure these images are built and pushed before deployment.
                        Run the main build pipeline for these applications first.
                        """)
                    }
                    
                    echo "\nâœ… All ${foundImages.size()} production images verified successfully"
                    env.IMAGE_MANIFESTS = groovy.json.JsonOutput.toJson(imageManifests)
                }
            }
        }
        
        // ================================================================================
        // STAGE 6: Update Latest Tags
        // ================================================================================
        stage('Update Latest Tags') {
            when {
                expression { params.UPDATE_LATEST_TAGS == true }
            }
            steps {
                script {
                    echo "ðŸ·ï¸ Updating 'latest' tags to production versions..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def updateResults = [:]
                    
                    // Login to Docker registry
                    bat """
                        echo %ARTIFACTORY_CREDS_PSW% | docker login %DOCKER_REGISTRY% ^
                            -u %ARTIFACTORY_CREDS_USR% --password-stdin
                    """
                    
                    def updateJobs = [:]
                    
                    deployConfig.production.each { app, version ->
                        updateJobs[app] = {
                            echo "\n  Updating ${app}:latest to point to ${version}..."
                            
                            def imagePath = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}"
                            
                            try {
                                // Pull the specific version
                                def pullResult = bat(
                                    script: "docker pull ${imagePath}:${version}",
                                    returnStatus: true
                                )
                                
                                if (pullResult != 0) {
                                    throw new Exception("Failed to pull ${imagePath}:${version}")
                                }
                                
                                // Tag as latest
                                bat "docker tag ${imagePath}:${version} ${imagePath}:latest"
                                
                                // Push latest tag
                                def pushResult = bat(
                                    script: "docker push ${imagePath}:latest",
                                    returnStatus: true
                                )
                                
                                if (pushResult != 0) {
                                    throw new Exception("Failed to push ${imagePath}:latest")
                                }
                                
                                echo "  âœ… ${app}:latest now points to ${version}"
                                updateResults[app] = 'success'
                                
                                // Clean up local images
                                bat """
                                    docker rmi ${imagePath}:${version} 2>nul || exit 0
                                    docker rmi ${imagePath}:latest 2>nul || exit 0
                                """
                                
                            } catch (Exception e) {
                                echo "  âŒ Failed to update ${app}:latest: ${e.message}"
                                updateResults[app] = 'failed'
                                env.ROLLBACK_REQUIRED = 'true'
                                throw e
                            }
                        }
                    }
                    
                    try {
                        parallel updateJobs
                    } catch (Exception e) {
                        echo "\nâŒ Some tag updates failed"
                        if (params.ROLLBACK_ON_FAILURE) {
                            echo "Rollback will be initiated..."
                        }
                        throw e
                    }
                    
                    // Logout
                    bat "docker logout %DOCKER_REGISTRY%"
                    
                    echo "\nâœ… All 'latest' tags updated successfully"
                    env.UPDATE_RESULTS = groovy.json.JsonOutput.toJson(updateResults)
                }
            }
        }
        
        // ================================================================================
        // STAGE 7: Deploy to Production
        // ================================================================================
        stage('Deploy to Production') {
            steps {
                script {
                    echo "ðŸš€ Deploying to production environment..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def deploymentStatus = [:]
                    
                    deployConfig.production.each { app, version ->
                        echo "\n  Deploying ${app}:${version}..."
                        
                        def imagePath = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:latest"
                        
                        try {
                            // Example deployment strategies - uncomment/modify as needed
                            
                            // === Option 1: Docker Swarm ===
                            /*
                            def serviceExists = bat(
                                script: "@docker service ls --filter name=${app}-service --format \"{{.Name}}\" 2>nul",
                                returnStdout: true
                            ).trim()
                            
                            if (serviceExists) {
                                bat """
                                    docker service update ^
                                        --image ${imagePath} ^
                                        --update-parallelism 1 ^
                                        --update-delay 10s ^
                                        ${app}-service
                                """
                            } else {
                                bat """
                                    docker service create ^
                                        --name ${app}-service ^
                                        --replicas 2 ^
                                        --update-parallelism 1 ^
                                        --update-delay 10s ^
                                        ${imagePath}
                                """
                            }
                            */
                            
                            // === Option 2: Kubernetes ===
                            /*
                            bat """
                                kubectl set image deployment/${app} ${app}=${imagePath} ^
                                    --namespace=production --record
                                    
                                kubectl rollout status deployment/${app} ^
                                    --namespace=production --timeout=5m
                            """
                            */
                            
                            // === Option 3: Docker Compose ===
                            /*
                            writeFile file: "docker-compose-${app}.yml", text: """
version: '3.8'
services:
  ${app}:
    image: ${imagePath}
    restart: unless-stopped
    environment:
      - APP_VERSION=${version}
      - DEPLOYMENT_DATE=${new Date().format('yyyy-MM-dd HH:mm:ss')}
"""
                            bat """
                                docker-compose -f docker-compose-${app}.yml pull
                                docker-compose -f docker-compose-${app}.yml up -d
                            """
                            */
                            
                            // === Option 4: Direct Docker (for testing) ===
                            bat """
                                docker stop ${app} 2>nul || exit 0
                                docker rm ${app} 2>nul || exit 0
                                echo %ARTIFACTORY_CREDS_PSW% | docker login %DOCKER_REGISTRY% ^
                                    -u %ARTIFACTORY_CREDS_USR% --password-stdin
                                docker pull ${imagePath}
                                docker run -d ^
                                    --name ${app} ^
                                    --restart=unless-stopped ^
                                    --label "app.version=${version}" ^
                                    --label "deployment.date=${new Date().format('yyyy-MM-dd HH:mm:ss')}" ^
                                    --label "deployment.build=${env.BUILD_NUMBER}" ^
                                    ${imagePath}
                                docker logout %DOCKER_REGISTRY%
                            """
                            
                            echo "  âœ… ${app} deployed successfully"
                            deploymentStatus[app] = 'deployed'
                            
                        } catch (Exception e) {
                            echo "  âŒ Failed to deploy ${app}: ${e.message}"
                            deploymentStatus[app] = 'failed'
                            env.ROLLBACK_REQUIRED = 'true'
                            throw e
                        }
                    }
                    
                    env.DEPLOYMENT_STATUS = groovy.json.JsonOutput.toJson(deploymentStatus)
                    echo "\nâœ… All applications deployed successfully"
                }
            }
        }
        
        // ================================================================================
        // STAGE 8: Health Checks
        // ================================================================================
        stage('Health Checks') {
            when {
                expression { params.RUN_HEALTH_CHECKS == true }
            }
            steps {
                script {
                    echo "ðŸ¥ Running comprehensive health checks..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def healthStatus = [:]
                    def failedChecks = []
                    
                    // Wait for services to stabilize
                    echo "  â³ Waiting 20 seconds for services to stabilize..."
                    sleep(time: 20, unit: 'SECONDS')
                    
                    deployConfig.production.each { app, version ->
                        echo "\n  Checking ${app} (v${version})..."
                        
                        def checks = [:]
                        
                        // Check 1: Container status
                        def containerInfo = ''
                        try {
                            containerInfo = bat(
                                script: "@docker inspect ${app} --format \"{{json .State}}\" 2>nul",
                                returnStdout: true
                            ).trim()
                            
                            if (containerInfo && containerInfo.contains('"Running":true')) {
                                checks.container = 'running'
                                echo "    âœ… Container: Running"
                                
                                // Get container health if defined
                                if (containerInfo.contains('"Health"')) {
                                    def healthMatch = containerInfo =~ /"Status":"([^"]+)"/
                                    if (healthMatch) {
                                        echo "    ðŸ“Š Health status: ${healthMatch[0][1]}"
                                        checks.health = healthMatch[0][1]
                                    }
                                }
                            } else {
                                checks.container = 'not_running'
                                echo "    âŒ Container: Not running"
                                failedChecks.add("${app}: Container not running")
                            }
                        } catch (Exception e) {
                            checks.container = 'not_found'
                            echo "    âŒ Container: Not found"
                            failedChecks.add("${app}: Container not found")
                        }
                        
                        // Check 2: Recent logs for errors
                        if (checks.container == 'running') {
                            try {
                                def logs = bat(
                                    script: "@docker logs ${app} --since 30s 2>&1 | findstr /i \"error fatal exception\" 2>nul || echo \"\"",
                                    returnStdout: true
                                ).trim()
                                
                                if (logs && logs.length() > 0) {
                                    checks.logs = 'errors_found'
                                    echo "    âš ï¸ Logs: Errors detected in recent logs"
                                } else {
                                    checks.logs = 'clean'
                                    echo "    âœ… Logs: No errors in recent logs"
                                }
                            } catch (Exception e) {
                                checks.logs = 'unknown'
                            }
                        }
                        
                        // Check 3: HTTP endpoint (if applicable)
                        // Customize this based on your applications
                        /*
                        def httpPort = getAppPort(app)  // Implement based on your setup
                        if (httpPort) {
                            def httpStatus = bat(
                                script: """
                                    @curl -s -o nul -w "%%{http_code}" ^
                                         --max-time 5 ^
                                         http://localhost:${httpPort}/health || echo 000
                                """,
                                returnStdout: true
                            ).trim()
                            
                            if (httpStatus == "200") {
                                checks.http = 'healthy'
                                echo "    âœ… HTTP health check: Passed (${httpStatus})"
                            } else {
                                checks.http = 'unhealthy'
                                echo "    âŒ HTTP health check: Failed (${httpStatus})"
                                failedChecks.add("${app}: HTTP health check failed")
                            }
                        }
                        */
                        
                        healthStatus[app] = checks
                    }
                    
                    // Overall health assessment
                    if (failedChecks.size() > 0) {
                        env.ROLLBACK_REQUIRED = 'true'
                        error("""
                        âŒ Health checks failed:
                        ${failedChecks.join('\n')}
                        
                        ${params.ROLLBACK_ON_FAILURE ? 'Initiating rollback...' : 'Please check the applications manually.'}
                        """)
                    }
                    
                    echo "\nâœ… All health checks passed"
                    env.HEALTH_STATUS = groovy.json.JsonOutput.toJson(healthStatus)
                }
            }
        }
        
        // ================================================================================
        // STAGE 9: Record Deployment
        // ================================================================================
        stage('Record Deployment') {
            when {
                expression { env.ROLLBACK_REQUIRED != 'true' }
            }
            steps {
                script {
                    echo "ðŸ“ Recording successful deployment..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    
                    // Create comprehensive deployment record
                    def deploymentInfo = [
                        timestamp: new Date().format("yyyy-MM-dd HH:mm:ss"),
                        build_number: env.BUILD_NUMBER,
                        deployed_by: env.BUILD_USER ?: 'Jenkins',
                        branch: env.GIT_BRANCH_NAME,
                        git_commit: env.GIT_COMMIT_HASH,
                        git_commit_short: env.GIT_COMMIT_SHORT,
                        versions: deployConfig.production,
                        health_checks: env.HEALTH_STATUS ? groovy.json.JsonSlurper().parseText(env.HEALTH_STATUS) : [:],
                        update_results: env.UPDATE_RESULTS ? groovy.json.JsonSlurper().parseText(env.UPDATE_RESULTS) : [:],
                        deployment_status: env.DEPLOYMENT_STATUS ? groovy.json.JsonSlurper().parseText(env.DEPLOYMENT_STATUS) : [:]
                    ]
                    
                    // Write deployment record
                    def recordFile = "deployment-record-${env.BUILD_NUMBER}.yaml"
                    writeYaml file: recordFile, data: deploymentInfo
                    
                    // Archive the deployment record
                    archiveArtifacts artifacts: recordFile, fingerprint: true
                    
                    // Upload to Artifactory metadata
                    bat """
                        curl -u %ARTIFACTORY_CREDS_USR%:%ARTIFACTORY_CREDS_PSW% ^
                             -T ${recordFile} ^
                             "https://${env.DOCKER_REGISTRY}/artifactory/${env.DOCKER_REPO}/${env.BUILD_MANIFESTS_PATH}/deployments/deployment-${env.BUILD_NUMBER}.yaml"
                    """
                    
                    // Display deployment summary
                    echo """
                    
                    â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                    â•‘      PRODUCTION DEPLOYMENT SUCCESSFUL       â•‘
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Build:      #${env.BUILD_NUMBER}
                    â•‘ Timestamp:  ${deploymentInfo.timestamp}
                    â•‘ Deployed by: ${deploymentInfo.deployed_by}
                    â•‘ Branch:     ${env.GIT_BRANCH_NAME}
                    â•‘ Commit:     ${env.GIT_COMMIT_SHORT}
                    â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ Deployed Versions:
                    """
                    
                    deployConfig.production.each { app, version ->
                        echo "â•‘   â€¢ ${app}: ${version}"
                    }
                    
                    echo """â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                    â•‘ All health checks: PASSED âœ…
                    â•‘ All images updated: SUCCESS âœ…
                    â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    
                    Deployment record saved to: ${recordFile}
                    """
                    
                    // Update deployment-versions.yaml with deployment metadata
                    deployConfig.last_deployment = [
                        timestamp: deploymentInfo.timestamp,
                        build_number: env.BUILD_NUMBER,
                        git_commit: env.GIT_COMMIT_SHORT
                    ]
                    
                    writeYaml file: 'deployment-versions.yaml', data: deployConfig, overwrite: true
                }
            }
        }
        
        // ================================================================================
        // STAGE 10: Rollback (if needed)
        // ================================================================================
        stage('Rollback') {
            when {
                allOf {
                    expression { env.ROLLBACK_REQUIRED == 'true' }
                    expression { params.ROLLBACK_ON_FAILURE == true }
                    expression { env.PREVIOUS_VERSIONS != null && env.PREVIOUS_VERSIONS != '' }
                }
            }
            steps {
                script {
                    echo "âš ï¸ INITIATING ROLLBACK..."
                    echo "Deployment failed - reverting to previous state"
                    
                    def previousVersions = groovy.json.JsonSlurper().parseText(env.PREVIOUS_VERSIONS)
                    
                    // Login to Docker
                    bat """
                        echo %ARTIFACTORY_CREDS_PSW% | docker login %DOCKER_REGISTRY% ^
                            -u %ARTIFACTORY_CREDS_USR% --password-stdin
                    """
                    
                    previousVersions.each { app, info ->
                        echo "\n  Rolling back ${app}..."
                        
                        try {
                            // Find the previous version by digest
                            def imagePath = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}"
                            
                            // Note: Rollback strategy depends on how you track versions
                            // This is a simplified approach
                            echo "    âš ï¸ Manual intervention may be required for ${app}"
                            echo "    Previous digest: ${info.digest}"
                            
                            // For direct Docker deployment, restart with previous image
                            /*
                            bat """
                                docker stop ${app} 2>nul || exit 0
                                docker rm ${app} 2>nul || exit 0
                                rem Manual rollback required - previous version needs to be identified
                            """
                            */
                            
                        } catch (Exception e) {
                            echo "    âŒ Rollback failed for ${app}: ${e.message}"
                        }
                    }
                    
                    bat "docker logout %DOCKER_REGISTRY%"
                    
                    error("""
                    âš ï¸ DEPLOYMENT FAILED - ROLLBACK INITIATED
                    
                    The deployment has failed and a rollback has been attempted.
                    Please verify the system state and manually intervene if necessary.
                    
                    Check the deployment logs for details on what failed.
                    """)
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo """
                ========================================
                âœ… DEPLOYMENT COMPLETED SUCCESSFULLY
                ========================================
                All applications have been deployed to production.
                All health checks have passed.
                """
                
                // Send success notification
                if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def appVersions = deployConfig.production.collect { k, v -> "${k}:${v}" }.join(', ')
                    
                    def payload = groovy.json.JsonOutput.toJson([
                        text: "âœ… *Production Deployment Successful*",
                        attachments: [[
                            color: "good",
                            fields: [
                                [title: "Build", value: "#${env.BUILD_NUMBER}", short: true],
                                [title: "Deployed By", value: env.BUILD_USER ?: 'Jenkins', short: true],
                                [title: "Applications", value: appVersions, short: false],
                                [title: "Commit", value: env.GIT_COMMIT_SHORT, short: true]
                            ],
                            footer: "Jenkins CI/CD",
                            ts: System.currentTimeMillis() / 1000
                        ]]
                    ])
                    
                    bat """
                        @curl -s -X POST -H "Content-type: application/json" ^
                             --data "${payload.replace('"', '\\"')}" ^
                             "${params.SLACK_WEBHOOK_URL}"
                    """
                }
            }
        }
        
        failure {
            script {
                echo """
                ========================================
                âŒ DEPLOYMENT FAILED
                ========================================
                The deployment has failed. Please check the logs above for details.
                
                ${env.ROLLBACK_REQUIRED == 'true' && params.ROLLBACK_ON_FAILURE ? 
                  'ROLLBACK HAS BEEN ATTEMPTED' : 
                  'NO AUTOMATIC ROLLBACK PERFORMED'}
                
                MANUAL INTERVENTION MAY BE REQUIRED
                """
                
                // Send failure notification
                if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
                    def payload = groovy.json.JsonOutput.toJson([
                        text: "âŒ *Production Deployment FAILED*",
                        attachments: [[
                            color: "danger",
                            fields: [
                                [title: "Build", value: "#${env.BUILD_NUMBER}", short: true],
                                [title: "Failed By", value: env.BUILD_USER ?: 'Jenkins', short: true],
                                [title: "Status", value: "FAILED - Manual intervention required", short: false],
                                [title: "Rollback", value: env.ROLLBACK_REQUIRED == 'true' ? "Attempted" : "Not performed", short: true]
                            ],
                            footer: "Jenkins CI/CD",
                            ts: System.currentTimeMillis() / 1000
                        ]]
                    ])
                    
                    bat """
                        @curl -s -X POST -H "Content-type: application/json" ^
                             --data "${payload.replace('"', '\\"')}" ^
                             "${params.SLACK_WEBHOOK_URL}"
                    """
                }
            }
        }
        
        always {
            script {
                // Cleanup
                try {
                    bat """
                        docker logout %DOCKER_REGISTRY% 2>nul || exit 0
                        docker system prune -f 2>nul || exit 0
                    """
                    
                    // Clean temporary files
                    bat """
                        del /Q deployment-backup-*.json 2>nul || exit 0
                        del /Q docker-compose-*.yml 2>nul || exit 0
                    """
                } catch (Exception e) {
                    echo "Cleanup error (non-critical): ${e.message}"
                }
                
                // Clean workspace
                deleteDir()
            }
        }
    }
}