// Enhanced Jenkinsfile.deploy - Production Deployment Pipeline
// This pipeline manages production deployments and 'latest' tag updates

pipeline {
    agent any
    
    parameters {
        booleanParam(
            name: 'CONFIRM_DEPLOYMENT',
            defaultValue: false,
            description: 'Check this box to confirm production deployment'
        )
        booleanParam(
            name: 'UPDATE_LATEST_TAGS',
            defaultValue: true,
            description: 'Update the "latest" tags to point to production versions'
        )

        string(
            name: 'SLACK_WEBHOOK_URL',
            defaultValue: '',
            description: 'Slack webhook URL for deployment notifications'
        )
    }
    
    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '30'))
        disableConcurrentBuilds()
    }
    
    environment {
        // Hardcoded configuration values for reliability
        DOCKER_REGISTRY = 'trialqlk1tc.jfrog.io'
        DOCKER_REPO = 'dockertest-docker'
        DOCKER_LATEST_PATH = 'docker-latest'
        BUILD_MANIFESTS_PATH = 'metadata/build-manifests'
        ARTIFACTORY_CREDS = credentials('artifactory-credentials')


    }
    
    // NO TRIGGERS - This pipeline is manual only
    
    stages {
        // ================================================================================
        // STAGE 1: Pre-flight Checks
        // ================================================================================
        stage('Pre-flight Checks') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> PRODUCTION DEPLOYMENT PIPELINE"
                    echo "========================================="
                    
                    if (!params.CONFIRM_DEPLOYMENT) {
                        error("❌ Deployment not confirmed. Please check 'CONFIRM_DEPLOYMENT' to proceed.")
                    }
                    
                    echo "✅ Deployment confirmed by user"
                    echo "Build Number: ${env.BUILD_NUMBER}"
                    echo "Triggered by: ${env.BUILD_USER ?: 'Jenkins'}"
                    echo "Update Latest Tags: ${params.UPDATE_LATEST_TAGS}"
                    echo "========================================"
                }
            }
        }
        
        // ================================================================================
        // STAGE 2: Checkout and Validate
        // ================================================================================
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Get current branch - handle detached HEAD state in Jenkins
                    try {
                        env.GIT_BRANCH_NAME = bat(
                            script: '@git rev-parse --abbrev-ref HEAD',
                            returnStdout: true
                        ).trim()

                        // If in detached HEAD state (common in Jenkins), try alternative methods
                        if (env.GIT_BRANCH_NAME == 'HEAD') {
                            // Method 1: Try to get branch from remote tracking
                            try {
                                def remoteBranch = bat(
                                    script: '@git branch -r --contains HEAD 2>nul',
                                    returnStdout: true
                                ).trim()

                                if (remoteBranch.contains('origin/main')) {
                                    env.GIT_BRANCH_NAME = 'main'
                                } else if (remoteBranch.contains('origin/master')) {
                                    env.GIT_BRANCH_NAME = 'master'
                                } else {
                                    // Method 2: Use Jenkins environment variable if available
                                    env.GIT_BRANCH_NAME = env.BRANCH_NAME ?: env.GIT_BRANCH ?: 'main'
                                    if (env.GIT_BRANCH_NAME.contains('origin/')) {
                                        env.GIT_BRANCH_NAME = env.GIT_BRANCH_NAME.replaceAll('.*origin/', '')
                                    }
                                }
                            } catch (Exception e2) {
                                echo "⚠️ Could not determine branch from remote: ${e2.message}"
                                env.GIT_BRANCH_NAME = 'main'  // Default assumption
                            }
                        }
                    } catch (Exception e) {
                        echo "⚠️ Could not determine branch name: ${e.message}"
                        env.GIT_BRANCH_NAME = 'main'  // Default assumption for deployment
                    }

                    echo "🔍 Detected branch: ${env.GIT_BRANCH_NAME}"

                    // Only allow deployment from main/master branch
                    if (env.GIT_BRANCH_NAME != 'main' && env.GIT_BRANCH_NAME != 'master') {
                        error("❌ Deployment only allowed from main/master branch. Current branch: ${env.GIT_BRANCH_NAME}")
                    }
                    
                    // Get git commit info
                    env.GIT_COMMIT_HASH = bat(
                        script: '@git rev-parse HEAD',
                        returnStdout: true
                    ).trim()
                    
                    env.GIT_COMMIT_SHORT = bat(
                        script: '@git rev-parse --short=8 HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "✅ On ${env.GIT_BRANCH_NAME} branch"
                    echo "📍 Commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        // ================================================================================
        // STAGE 3: Read Production Versions
        // ================================================================================
        stage('Read Production Versions') {
            steps {
                script {
                    echo "📖 Reading production versions from deployment-versions.yaml..."
                    
                    if (!fileExists('deployment-versions.yaml')) {
                        error("❌ deployment-versions.yaml not found in repository root")
                    }
                    
                    // Read the YAML file
                    def deployConfig = readYaml file: 'deployment-versions.yaml'



                    // Validate structure
                    if (!deployConfig.production || deployConfig.production.size() == 0) {
                        error("❌ No production versions defined in deployment-versions.yaml")
                    }

                    echo "\n>>> Configuration (hardcoded in pipeline):"
                    echo "  Registry: ${env.DOCKER_REGISTRY}"
                    echo "  Repository: ${env.DOCKER_REPO}"
                    echo "  Path: ${env.DOCKER_LATEST_PATH}"
                    echo "  Manifests Path: ${env.BUILD_MANIFESTS_PATH}"
                    
                    echo "\n>>> Applications to deploy:"
                    deployConfig.production.each { app, version ->
                        // Validate version format
                        if (!version.matches('^\\d+\\.\\d+\\.\\d+$')) {
                            error("❌ Invalid version format for ${app}: ${version} (expected: X.Y.Z)")
                        }
                        env["VERSION_${app.toUpperCase().replace('-', '_')}"] = version
                        echo "  ${app}: ${version}"
                    }
                    
                    // Store for later stages
                    env.DEPLOY_CONFIG_JSON = groovy.json.JsonOutput.toJson(deployConfig.production)
                }
            }
        }

        // ================================================================================
        // STAGE 4: Verify Images Exist
        // ================================================================================
        stage('Verify Images') {
            steps {
                script {
                    echo "🔍 Verifying all production images exist in Artifactory..."

                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def missingImages = []
                    def foundImages = []

                    // Login to Docker registry first
                    withCredentials([usernamePassword(
                        credentialsId: 'artifactory-credentials',
                        usernameVariable: 'ARTIFACTORY_USER',
                        passwordVariable: 'ARTIFACTORY_PASS'
                    )]) {
                        bat "echo %ARTIFACTORY_PASS% | docker login %DOCKER_REGISTRY% -u %ARTIFACTORY_USER% --password-stdin"

                        deployConfig.production.each { app, version ->
                            echo "\n  Checking ${app}:${version}..."

                            def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:${version}"
                            echo "    Image: ${imageName}"

                            // Use docker pull to check if image exists (same method as Jenkinsfile-NoCleanup)
                            def imageExists = bat(
                                script: "docker pull ${imageName} >nul 2>&1",
                                returnStatus: true
                            ) == 0

                            if (imageExists) {
                                echo "    ✅ Found: ${imageName}"
                                foundImages.add("${app}:${version}")

                                // Clean up the pulled image to save space
                                bat "docker rmi ${imageName} 2>nul || exit 0"
                            } else {
                                echo "    ❌ NOT FOUND: ${imageName}"
                                missingImages.add("${app}:${version}")
                            }
                        }

                        bat "docker logout ${env.DOCKER_REGISTRY}"
                    }
                    
                    if (missingImages.size() > 0) {
                        error("""
                        ❌ Missing images in Artifactory:
                        ${missingImages.join('\n')}
                        
                        Please ensure these images are built and pushed before deployment.
                        Run the main build pipeline for these applications first.
                        """)
                    }
                    
                    echo "\n✅ All ${foundImages.size()} production images verified successfully"
                    env.IMAGE_MANIFESTS = groovy.json.JsonOutput.toJson(imageManifests)
                }
            }
        }
        
        // ================================================================================
        // STAGE 6: Update Latest Tags
        // ================================================================================
        stage('Update Latest Tags') {
            when {
                expression { params.UPDATE_LATEST_TAGS == true }
            }
            steps {
                script {
                    echo "🏷️ Updating 'latest' tags to production versions..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def updateResults = [:]
                    
                    // Login to Docker registry
                    bat """
                        echo %ARTIFACTORY_CREDS_PSW% | docker login %DOCKER_REGISTRY% ^
                            -u %ARTIFACTORY_CREDS_USR% --password-stdin
                    """
                    
                    def updateJobs = [:]
                    
                    deployConfig.production.each { app, version ->
                        updateJobs[app] = {
                            echo "\n  Updating ${app}:latest to point to ${version}..."
                            
                            def imagePath = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}"
                            
                            try {
                                // Pull the specific version
                                def pullResult = bat(
                                    script: "docker pull ${imagePath}:${version}",
                                    returnStatus: true
                                )
                                
                                if (pullResult != 0) {
                                    throw new Exception("Failed to pull ${imagePath}:${version}")
                                }
                                
                                // Tag as latest
                                bat "docker tag ${imagePath}:${version} ${imagePath}:latest"
                                
                                // Push latest tag
                                def pushResult = bat(
                                    script: "docker push ${imagePath}:latest",
                                    returnStatus: true
                                )
                                
                                if (pushResult != 0) {
                                    throw new Exception("Failed to push ${imagePath}:latest")
                                }
                                
                                echo "  ✅ ${app}:latest now points to ${version}"
                                updateResults[app] = 'success'
                                
                                // Clean up local images
                                bat """
                                    docker rmi ${imagePath}:${version} 2>nul || exit 0
                                    docker rmi ${imagePath}:latest 2>nul || exit 0
                                """
                                
                            } catch (Exception e) {
                                echo "  ❌ Failed to update ${app}:latest: ${e.message}"
                                updateResults[app] = 'failed'
                                throw e
                            }
                        }
                    }
                    
                    try {
                        parallel updateJobs
                    } catch (Exception e) {
                        echo "\n❌ Some tag updates failed"
                        if (params.ROLLBACK_ON_FAILURE) {
                            echo "Rollback will be initiated..."
                        }
                        throw e
                    }
                    
                    // Logout
                    bat "docker logout %DOCKER_REGISTRY%"
                    
                    echo "\n✅ All 'latest' tags updated successfully"
                    env.UPDATE_RESULTS = groovy.json.JsonOutput.toJson(updateResults)
                }
            }
        }
        
        // ================================================================================
        // STAGE 7: Deploy to Production
        // ================================================================================
        stage('Deploy to Production') {
            steps {
                script {
                    echo "🚀 Deploying to production environment..."
                    
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def deploymentStatus = [:]
                    
                    deployConfig.production.each { app, version ->
                        echo "\n  Deploying ${app}:${version}..."
                        
                        def imagePath = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:latest"
                        
                        try {
                            // Example deployment strategies - uncomment/modify as needed
                            
                            // === Option 1: Docker Swarm ===
                            /*
                            def serviceExists = bat(
                                script: "@docker service ls --filter name=${app}-service --format \"{{.Name}}\" 2>nul",
                                returnStdout: true
                            ).trim()
                            
                            if (serviceExists) {
                                bat """
                                    docker service update ^
                                        --image ${imagePath} ^
                                        --update-parallelism 1 ^
                                        --update-delay 10s ^
                                        ${app}-service
                                """
                            } else {
                                bat """
                                    docker service create ^
                                        --name ${app}-service ^
                                        --replicas 2 ^
                                        --update-parallelism 1 ^
                                        --update-delay 10s ^
                                        ${imagePath}
                                """
                            }
                            */
                            
                            // === Option 2: Kubernetes ===
                            /*
                            bat """
                                kubectl set image deployment/${app} ${app}=${imagePath} ^
                                    --namespace=production --record
                                    
                                kubectl rollout status deployment/${app} ^
                                    --namespace=production --timeout=5m
                            """
                            */
                            
                            // === Option 3: Docker Compose ===
                            /*
                            writeFile file: "docker-compose-${app}.yml", text: """
version: '3.8'
services:
  ${app}:
    image: ${imagePath}
    restart: unless-stopped
    environment:
      - APP_VERSION=${version}
      - DEPLOYMENT_DATE=${new Date().format('yyyy-MM-dd HH:mm:ss')}
"""
                            bat """
                                docker-compose -f docker-compose-${app}.yml pull
                                docker-compose -f docker-compose-${app}.yml up -d
                            """
                            */
                            
                            // === Option 4: Direct Docker (for testing) ===
                            bat """
                                docker stop ${app} 2>nul || exit 0
                                docker rm ${app} 2>nul || exit 0
                                echo %ARTIFACTORY_CREDS_PSW% | docker login %DOCKER_REGISTRY% ^
                                    -u %ARTIFACTORY_CREDS_USR% --password-stdin
                                docker pull ${imagePath}
                                docker run -d ^
                                    --name ${app} ^
                                    --restart=unless-stopped ^
                                    --label "app.version=${version}" ^
                                    --label "deployment.date=${new Date().format('yyyy-MM-dd HH:mm:ss')}" ^
                                    --label "deployment.build=${env.BUILD_NUMBER}" ^
                                    ${imagePath}
                                docker logout %DOCKER_REGISTRY%
                            """
                            
                            echo "  ✅ ${app} deployed successfully"
                            deploymentStatus[app] = 'deployed'
                            
                        } catch (Exception e) {
                            echo "  ❌ Failed to deploy ${app}: ${e.message}"
                            deploymentStatus[app] = 'failed'
                            throw e
                        }
                    }
                    
                    env.DEPLOYMENT_STATUS = groovy.json.JsonOutput.toJson(deploymentStatus)
                    echo "\n✅ All applications deployed successfully"
                }
            }
        }

        // ================================================================================
        // STAGE 8: Record Deployment
        // ================================================================================
        stage('Record Deployment') {
            steps {
                script {
                    echo "📝 Recording successful deployment..."

                    def deployConfig = readYaml file: 'deployment-versions.yaml'

                    // Create deployment record
                    def deploymentInfo = [
                        timestamp: new Date().format("yyyy-MM-dd HH:mm:ss"),
                        build_number: env.BUILD_NUMBER,
                        deployed_by: env.BUILD_USER ?: 'Jenkins',
                        branch: env.GIT_BRANCH_NAME,
                        git_commit: env.GIT_COMMIT_HASH,
                        git_commit_short: env.GIT_COMMIT_SHORT,
                        versions: deployConfig.production,
                        update_results: env.UPDATE_RESULTS ? groovy.json.JsonSlurper().parseText(env.UPDATE_RESULTS) : [:],
                        deployment_status: env.DEPLOYMENT_STATUS ? groovy.json.JsonSlurper().parseText(env.DEPLOYMENT_STATUS) : [:]
                    ]
                    
                    // Write deployment record
                    def recordFile = "deployment-record-${env.BUILD_NUMBER}.yaml"
                    writeYaml file: recordFile, data: deploymentInfo
                    
                    // Archive the deployment record
                    archiveArtifacts artifacts: recordFile, fingerprint: true
                    
                    // Upload to Artifactory metadata
                    bat """
                        curl -u %ARTIFACTORY_CREDS_USR%:%ARTIFACTORY_CREDS_PSW% ^
                             -T ${recordFile} ^
                             "https://${env.DOCKER_REGISTRY}/artifactory/${env.DOCKER_REPO}/${env.BUILD_MANIFESTS_PATH}/deployments/deployment-${env.BUILD_NUMBER}.yaml"
                    """
                    
                    // Display deployment summary
                    echo """
                    
                    ╔════════════════════════════════════════════╗
                    ║      PRODUCTION DEPLOYMENT SUCCESSFUL       ║
                    ╠════════════════════════════════════════════╣
                    ║ Build:      #${env.BUILD_NUMBER}
                    ║ Timestamp:  ${deploymentInfo.timestamp}
                    ║ Deployed by: ${deploymentInfo.deployed_by}
                    ║ Branch:     ${env.GIT_BRANCH_NAME}
                    ║ Commit:     ${env.GIT_COMMIT_SHORT}
                    ╠════════════════════════════════════════════╣
                    ║ Deployed Versions:
                    """
                    
                    deployConfig.production.each { app, version ->
                        echo "║   • ${app}: ${version}"
                    }
                    
                    echo """╠════════════════════════════════════════════╣
                    ║ All health checks: PASSED ✅
                    ║ All images updated: SUCCESS ✅
                    ╚════════════════════════════════════════════╝
                    
                    Deployment record saved to: ${recordFile}
                    """
                    
                    // Update deployment-versions.yaml with deployment metadata
                    deployConfig.last_deployment = [
                        timestamp: deploymentInfo.timestamp,
                        build_number: env.BUILD_NUMBER,
                        git_commit: env.GIT_COMMIT_SHORT
                    ]
                    
                    writeYaml file: 'deployment-versions.yaml', data: deployConfig, overwrite: true
                }
            }
        }

    }
    
    post {
        success {
            script {
                echo """
                ========================================
                ✅ DEPLOYMENT COMPLETED SUCCESSFULLY
                ========================================
                All applications have been deployed to production.
                Latest tags have been updated successfully.
                """
                
                // Send success notification
                if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
                    def deployConfig = readYaml file: 'deployment-versions.yaml'
                    def appVersions = deployConfig.production.collect { k, v -> "${k}:${v}" }.join(', ')
                    
                    def payload = groovy.json.JsonOutput.toJson([
                        text: "✅ *Production Deployment Successful*",
                        attachments: [[
                            color: "good",
                            fields: [
                                [title: "Build", value: "#${env.BUILD_NUMBER}", short: true],
                                [title: "Deployed By", value: env.BUILD_USER ?: 'Jenkins', short: true],
                                [title: "Applications", value: appVersions, short: false],
                                [title: "Commit", value: env.GIT_COMMIT_SHORT, short: true]
                            ],
                            footer: "Jenkins CI/CD",
                            ts: System.currentTimeMillis() / 1000
                        ]]
                    ])
                    
                    bat """
                        @curl -s -X POST -H "Content-type: application/json" ^
                             --data "${payload.replace('"', '\\"')}" ^
                             "${params.SLACK_WEBHOOK_URL}"
                    """
                }
            }
        }
        
        failure {
            script {
                echo """
                ========================================
                ❌ DEPLOYMENT FAILED
                ========================================
                The deployment has failed. Please check the logs above for details.

                MANUAL INTERVENTION MAY BE REQUIRED
                """
                
                // Send failure notification
                if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
                    def payload = groovy.json.JsonOutput.toJson([
                        text: "❌ *Production Deployment FAILED*",
                        attachments: [[
                            color: "danger",
                            fields: [
                                [title: "Build", value: "#${env.BUILD_NUMBER}", short: true],
                                [title: "Failed By", value: env.BUILD_USER ?: 'Jenkins', short: true],
                                [title: "Status", value: "FAILED - Manual intervention required", short: false]
                            ],
                            footer: "Jenkins CI/CD",
                            ts: System.currentTimeMillis() / 1000
                        ]]
                    ])
                    
                    bat """
                        @curl -s -X POST -H "Content-type: application/json" ^
                             --data "${payload.replace('"', '\\"')}" ^
                             "${params.SLACK_WEBHOOK_URL}"
                    """
                }
            }
        }
        
        always {
            script {
                // Cleanup
                try {
                    bat """
                        docker logout %DOCKER_REGISTRY% 2>nul || exit 0
                        docker system prune -f 2>nul || exit 0
                    """
                    
                    // Clean temporary files
                    bat """
                        del /Q docker-compose-*.yml 2>nul || exit 0
                    """
                } catch (Exception e) {
                    echo "Cleanup error (non-critical): ${e.message}"
                }
                
                // Clean workspace
                deleteDir()
            }
        }
    }
}