// Enhanced Jenkinsfile with Production Version Protection
// This pipeline reads deployment-versions.yaml and protects production versions

pipeline {
    agent any

    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: '',
            description: 'Branch to build (leave empty for automatic detection from webhook)'
        )
        choice(
            name: 'DEPLOY_TARGET',
            choices: ['auto', 'docker-latest', 'docker-dev'],
            description: 'Where to deploy (auto = based on branch)'
        )
        booleanParam(
            name: 'FORCE_BUILD',
            defaultValue: false,
            description: 'Force rebuild even if no changes detected'
        )
        booleanParam(
            name: 'OVERRIDE_PROTECTION',
            defaultValue: false,
            description: 'Override production version protection (USE WITH CAUTION)'
        )
        string(
            name: 'SLACK_WEBHOOK_URL',
            defaultValue: '',
            description: 'Slack webhook URL for notifications (optional)'
        )
        booleanParam(
            name: 'NOTIFY_ON_SUCCESS',
            defaultValue: false,
            description: 'Send notifications on successful builds (default: failures only)'
        )
    }

    triggers {
        githubPush()
    }

    environment {
        // Fix for Git whatchanged deprecation
        GIT_WHATCHANGED_OPTS = '--i-still-use-this'
        GIT_PAGER = 'cat'  // Disable pager to avoid issues
        
        // Artifactory credentials
        ARTIFACTORY_CREDS = credentials('artifactory-credentials')

        // Build metadata
        BUILD_NUMBER = "${BUILD_NUMBER}"
        TIMESTAMP = "${new Date().format('yyyyMMdd-HHmmss')}"
        JENKINS_URL = "${env.JENKINS_URL ?: 'http://jenkins.local'}"
        JOB_NAME = "${env.JOB_NAME}"
        
        // Pipeline status flags
        NO_APPS = 'false'
        VALIDATION_FAILED = 'false'
        
        // Config values will be loaded from deployment-versions.yaml
        CONFIG_LOADED = 'false'
        PRODUCTION_VERSIONS = ''
    }

    stages {
        // ================================================================================
        // STAGE 1: Initialize Pipeline
        // ================================================================================
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> BUILD INITIALIZATION"
                    echo "========================================="
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Manual Branch Override: ${params.BRANCH_NAME ?: 'none'}"
                    echo "Deploy Target: ${params.DEPLOY_TARGET}"
                    echo "Force Build: ${params.FORCE_BUILD}"
                    echo "Override Protection: ${params.OVERRIDE_PROTECTION}"
                    echo "========================================="
                    
                    // Load configuration from deployment-versions.yaml if it exists
                    if (fileExists('deployment-versions.yaml')) {
                        def deployConfig = readYaml file: 'deployment-versions.yaml'
                        
                        // Load all config values into environment
                        env.DOCKER_REGISTRY = deployConfig.config.docker_registry
                        env.DOCKER_REPO = deployConfig.config.docker_repo
                        env.DOCKER_LATEST_PATH = deployConfig.config.docker_latest_path
                        env.DOCKER_DEV_PATH = deployConfig.config.docker_dev_path
                        env.METADATA_PATH = deployConfig.config.metadata_path
                        env.BUILD_MANIFESTS_PATH = deployConfig.config.build_manifests_path
                        env.TEMP_BUILDS_PATH = deployConfig.config.temp_builds_path
                        env.DEV_RETENTION_DAYS = deployConfig.config.dev_retention_days.toString()
                        env.LATEST_VERSIONS_TO_KEEP = deployConfig.config.latest_versions_to_keep.toString()
                        
                        // Store production versions for protection
                        env.PRODUCTION_VERSIONS = groovy.json.JsonOutput.toJson(deployConfig.production ?: [:])
                        
                        env.CONFIG_LOADED = 'true'
                        echo "[CONFIG] Loaded configuration from deployment-versions.yaml"
                        
                        // Display protected versions
                        if (deployConfig.production) {
                            echo "\n[PROTECTED] Production versions:"
                            deployConfig.production.each { app, version ->
                                echo "  â€¢ ${app}: ${version}"
                            }
                        }
                    } else {
                        // Use default values if config file doesn't exist
                        env.DOCKER_REGISTRY = 'trialqlk1tc.jfrog.io'
                        env.DOCKER_REPO = 'dockertest-docker'
                        env.DOCKER_LATEST_PATH = 'docker-latest'
                        env.DOCKER_DEV_PATH = 'docker-dev'
                        env.METADATA_PATH = 'metadata'
                        env.BUILD_MANIFESTS_PATH = 'metadata/build-manifests'
                        env.TEMP_BUILDS_PATH = 'metadata/temporary-builds'
                        env.DEV_RETENTION_DAYS = '14'
                        env.LATEST_VERSIONS_TO_KEEP = '10'
                        env.PRODUCTION_VERSIONS = '{}'
                        
                        echo "[CONFIG] Using default configuration (deployment-versions.yaml not found)"
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 2: Checkout Code
        // ================================================================================
        stage('Checkout') {
            steps {
                script {
                    deleteDir()
                    
                    // Simple checkout without changelog to avoid git whatchanged issue
                    if (params.BRANCH_NAME) {
                        checkout scm: [
                            $class: 'GitSCM',
                            branches: [[name: "*/${params.BRANCH_NAME}"]],
                            userRemoteConfigs: scm.userRemoteConfigs
                        ], changelog: false, poll: false
                        
                        env.GIT_BRANCH_NAME = params.BRANCH_NAME
                    } else {
                        checkout scm: scm, changelog: false, poll: false
                        
                        // Get branch name
                        try {
                            env.GIT_BRANCH_NAME = bat(
                                script: '@git rev-parse --abbrev-ref HEAD 2>nul',
                                returnStdout: true
                            ).trim()
                            
                            if (!env.GIT_BRANCH_NAME || env.GIT_BRANCH_NAME == 'HEAD') {
                                // Try alternative method for detached HEAD
                                def remoteBranch = bat(
                                    script: '@git branch -r --contains HEAD 2>nul',
                                    returnStdout: true
                                ).trim()
                                
                                if (remoteBranch && remoteBranch.contains('origin/')) {
                                    env.GIT_BRANCH_NAME = remoteBranch.replaceAll('.*origin/', '').trim()
                                } else {
                                    env.GIT_BRANCH_NAME = 'unknown'
                                }
                            }
                        } catch (Exception e) {
                            env.GIT_BRANCH_NAME = 'unknown'
                        }
                    }

                    // Clean up branch name if needed
                    if (env.GIT_BRANCH_NAME && env.GIT_BRANCH_NAME.contains('/')) {
                        def parts = env.GIT_BRANCH_NAME.split('/')
                        if (parts[0] == 'origin') {
                            env.GIT_BRANCH_NAME = parts[1..-1].join('/')
                        }
                    }

                    // Extract commit information
                    try {
                        env.GIT_COMMIT_HASH = bat(
                            script: '@git rev-parse HEAD',
                            returnStdout: true
                        ).trim()
                        env.GIT_COMMIT_SHORT = bat(
                            script: '@git rev-parse --short=8 HEAD',
                            returnStdout: true
                        ).trim()
                        env.GIT_COMMIT_MSG = bat(
                            script: '@git log -1 --pretty=%%B',
                            returnStdout: true
                        ).trim()
                        env.GIT_AUTHOR = bat(
                            script: '@git log -1 --pretty=%%ae',
                            returnStdout: true
                        ).trim()
                        
                        env.GIT_PREVIOUS_COMMIT = bat(
                            script: '@git rev-parse HEAD~1 2>nul || echo ""',
                            returnStdout: true
                        ).trim()
                    } catch (Exception e) {
                        env.GIT_COMMIT_HASH = "unknown"
                        env.GIT_COMMIT_SHORT = "unknown-${BUILD_NUMBER}"
                        env.GIT_COMMIT_MSG = "Unknown"
                        env.GIT_AUTHOR = "Unknown"
                        env.GIT_PREVIOUS_COMMIT = ""
                    }

                    echo "[BRANCH] ${env.GIT_BRANCH_NAME}"
                    echo "[COMMIT] ${env.GIT_COMMIT_SHORT} (${env.GIT_COMMIT_HASH})"
                    echo "[AUTHOR] ${env.GIT_AUTHOR}"
                    
                    // Reload configuration after checkout to get the latest deployment-versions.yaml
                    if (fileExists('deployment-versions.yaml')) {
                        def deployConfig = readYaml file: 'deployment-versions.yaml'
                        
                        // Reload all config values
                        env.DOCKER_REGISTRY = deployConfig.config.docker_registry
                        env.DOCKER_REPO = deployConfig.config.docker_repo
                        env.DOCKER_LATEST_PATH = deployConfig.config.docker_latest_path
                        env.DOCKER_DEV_PATH = deployConfig.config.docker_dev_path
                        env.METADATA_PATH = deployConfig.config.metadata_path
                        env.BUILD_MANIFESTS_PATH = deployConfig.config.build_manifests_path
                        env.TEMP_BUILDS_PATH = deployConfig.config.temp_builds_path
                        env.DEV_RETENTION_DAYS = deployConfig.config.dev_retention_days.toString()
                        env.LATEST_VERSIONS_TO_KEEP = deployConfig.config.latest_versions_to_keep.toString()
                        
                        // Update production versions
                        env.PRODUCTION_VERSIONS = groovy.json.JsonOutput.toJson(deployConfig.production ?: [:])
                        
                        env.CONFIG_LOADED = 'true'
                        echo "[CONFIG] Reloaded configuration from deployment-versions.yaml"
                        
                        // Display protected versions
                        if (deployConfig.production) {
                            echo "\n[PROTECTED] Production versions after reload:"
                            deployConfig.production.each { app, version ->
                                echo "  â€¢ ${app}: ${version} (protected)"
                            }
                        }
                    }

                    // Determine deployment path based on branch
                    if (params.DEPLOY_TARGET != 'auto') {
                        env.DEPLOY_PATH = params.DEPLOY_TARGET == 'docker-latest' ? env.DOCKER_LATEST_PATH : env.DOCKER_DEV_PATH
                    } else {
                        if (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master') {
                            env.DEPLOY_PATH = env.DOCKER_LATEST_PATH
                            echo "[DEPLOY] Main branch: using ${env.DEPLOY_PATH}"
                        } else {
                            env.DEPLOY_PATH = env.DOCKER_DEV_PATH
                            echo "[DEPLOY] Feature branch: using ${env.DEPLOY_PATH}"
                        }
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 3: Validate Applications
        // ================================================================================
        stage('Validate Applications') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> MANDATORY FILE VALIDATION"
                    echo "========================================="

                    def pythonApps = []
                    def validationErrors = []
                    def productionVersions = groovy.json.JsonSlurper().parseText(env.PRODUCTION_VERSIONS)

                    // Find all Dockerfiles using Windows commands
                    def dockerfiles = ''
                    try {
                        dockerfiles = bat(
                            script: '@dir /s /b Dockerfile 2>nul || echo ""',
                            returnStdout: true
                        ).trim()
                    } catch (Exception e) {
                        dockerfiles = ''
                    }

                    if (dockerfiles) {
                        dockerfiles.split('\r?\n').each { file ->
                            if (file && file.trim() && file.contains('Dockerfile')) {
                                def relativePath = file.replace(env.WORKSPACE + '\\', '').replace('\\', '/')
                                def parts = relativePath.split('/')

                                if (parts.length == 2 && parts[1] == 'Dockerfile') {
                                    def appName = parts[0]
                                    if (!appName.startsWith('.') && !appName.startsWith('@')) {
                                        pythonApps.add(appName)
                                        echo "[FOUND] Application: ${appName}"
                                    }
                                }
                            }
                        }
                    }

                    if (pythonApps.size() == 0) {
                        env.NO_APPS = 'true'
                        env.VALIDATED_APPS = ''
                        echo "[INFO] No applications with Dockerfiles found"
                        echo "[DEBUG] Searched in: ${env.WORKSPACE}"
                        echo "[DEBUG] Raw output: ${dockerfiles}"
                        return
                    }

                    echo "[APPS] Found ${pythonApps.size()} applications: ${pythonApps.join(', ')}"

                    // Validate each application
                    pythonApps.each { app ->
                        echo "\n[VALIDATING] ${app}..."

                        def requiredFiles = [
                            'Dockerfile',
                            'requirements.txt',
                            'README.md',
                            'version.txt'
                        ]

                        def missingFiles = []
                        requiredFiles.each { file ->
                            def filePath = "${app}/${file}"
                            if (!fileExists(filePath)) {
                                missingFiles.add(file)
                                echo "  âŒ Missing: ${file}"
                            } else {
                                echo "  âœ“ Found: ${file}"

                                // Validate version.txt format and check protection status
                                if (file == 'version.txt') {
                                    def version = readFile(filePath).trim()
                                    
                                    // Check if this is a protected production version
                                    if (productionVersions.containsKey(app) && productionVersions[app] == version) {
                                        echo "  ðŸ”’ PROTECTED VERSION: ${version} (production)"
                                    }
                                    
                                    // Validate format on main branch
                                    if (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master') {
                                        if (!version.matches('^\\d+\\.\\d+\\.\\d+$')) {
                                            validationErrors.add("${app}/version.txt has invalid format: '${version}' (expected: X.Y.Z)")
                                            echo "  âŒ Invalid version format: ${version}"
                                        } else {
                                            echo "  âœ“ Version: ${version}"
                                        }
                                    }
                                }
                            }
                        }

                        if (missingFiles.size() > 0) {
                            validationErrors.add("${app} is missing: ${missingFiles.join(', ')}")
                        }
                    }

                    // Fail if any validation errors
                    if (validationErrors.size() > 0) {
                        env.VALIDATION_FAILED = 'true'
                        error("""
                        ========================================
                        VALIDATION FAILED
                        ========================================
                        ${validationErrors.join('\n')}

                        All applications must contain:
                        â€¢ Dockerfile
                        â€¢ requirements.txt
                        â€¢ README.md
                        â€¢ version.txt (format: X.Y.Z)
                        ========================================
                        """)
                    } else {
                        echo "\nâœ… All applications validated successfully"
                        env.VALIDATED_APPS = pythonApps.join(',')
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 4: Detect Changes
        // ================================================================================
        stage('Detect Changes') {
            when {
                allOf {
                    expression { env.NO_APPS != 'true' }
                    expression { env.VALIDATION_FAILED != 'true' }
                    expression { env.VALIDATED_APPS != null && env.VALIDATED_APPS != '' }
                }
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> CHANGE DETECTION"
                    echo "========================================="

                    def pythonApps = env.VALIDATED_APPS.split(',')
                    def changedApps = []
                    def productionVersions = groovy.json.JsonSlurper().parseText(env.PRODUCTION_VERSIONS)

                    def isMainBranch = (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master')
                    echo "[INFO] Branch type: ${isMainBranch ? 'MAIN BRANCH' : 'FEATURE BRANCH'}"
                    echo "[INFO] Branch name: ${env.GIT_BRANCH_NAME}"
                    echo "[INFO] Detection strategy: ${isMainBranch ? 'Build if changed OR new version' : 'Build ONLY if changed'}"
                    echo ""

                    withCredentials([usernamePassword(
                        credentialsId: 'artifactory-credentials',
                        usernameVariable: 'ARTIFACTORY_USER',
                        passwordVariable: 'ARTIFACTORY_PASS'
                    )]) {
                        bat "echo %ARTIFACTORY_PASS% | docker login %DOCKER_REGISTRY% -u %ARTIFACTORY_USER% --password-stdin"

                        pythonApps.each { app ->
                            def needsBuild = false
                            def reason = ""
                            def isProtected = false

                            echo "[ANALYZING] ${app}..."
                            
                            // Read current version
                            def currentVersion = readFile("${app}/version.txt").trim()
                            echo "  Current version: ${currentVersion}"
                            
                            // Check if this version is protected
                            if (productionVersions.containsKey(app) && productionVersions[app] == currentVersion) {
                                isProtected = true
                                echo "  ðŸ”’ PROTECTED: This is a production version"
                            }

                            // For force build, check protection
                            if (params.FORCE_BUILD) {
                                if (isProtected && !params.OVERRIDE_PROTECTION) {
                                    needsBuild = false
                                    reason = "Protected production version - use OVERRIDE_PROTECTION to force"
                                } else {
                                    needsBuild = true
                                    reason = "Force build requested by user${isProtected ? ' (protection overridden)' : ''}"
                                }
                            } else {
                                // Check for file changes
                                def changeResult = checkAppChangedFiles(app)
                                def changedFiles = changeResult.files ?: []
                                def significantChanges = changedFiles.findAll { !it.endsWith('README.md') }
                                def hasSignificantChanges = significantChanges.size() > 0

                                if (hasSignificantChanges) {
                                    echo "  ðŸ“ Files changed in ${app} (${significantChanges.size()} significant):"
                                    significantChanges.each { file ->
                                        echo "    - ${file}"
                                    }
                                } else if (changedFiles.size() > 0) {
                                    echo "  ðŸ“ Only README changes in ${app}"
                                } else {
                                    echo "  âœ… No changes detected in ${app}"
                                }

                                // Determine the image tag
                                def imageTag = ''
                                def imageName = ''

                                if (env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                    imageTag = currentVersion
                                    imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:${imageTag}"
                                } else {
                                    def cleanBranchName = env.GIT_BRANCH_NAME
                                        .replaceAll('[^a-zA-Z0-9._-]', '-')
                                        .toLowerCase()
                                    imageTag = "${cleanBranchName}-${env.GIT_COMMIT_SHORT}"
                                    imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_DEV_PATH}/${app}:${imageTag}"
                                }

                                echo "  Image tag: ${imageTag}"

                                // Check if image already exists
                                def imageExists = bat(
                                    script: "docker pull ${imageName} >nul 2>&1",
                                    returnStatus: true
                                ) == 0

                                if (imageExists) {
                                    echo "  Image exists: YES"
                                    bat "docker rmi ${imageName} 2>nul || exit 0"
                                } else {
                                    echo "  Image exists: NO"
                                }

                                // Decision logic with protection
                                if (isProtected) {
                                    if (params.OVERRIDE_PROTECTION) {
                                        if (hasSignificantChanges || !imageExists) {
                                            needsBuild = true
                                            reason = "Protection overridden - ${hasSignificantChanges ? 'files changed' : 'image missing'}"
                                        } else {
                                            needsBuild = false
                                            reason = "Protected version - no changes and image exists"
                                        }
                                    } else {
                                        needsBuild = false
                                        reason = "Protected production version - managed by deployment pipeline"
                                    }
                                } else if (isMainBranch) {
                                    if (hasSignificantChanges) {
                                        needsBuild = true
                                        reason = "Files changed (${significantChanges.size()} files modified)"
                                    } else if (!imageExists) {
                                        needsBuild = true
                                        reason = "New version ${imageTag} needs to be built"
                                    } else {
                                        needsBuild = false
                                        reason = "No changes and image already exists"
                                    }
                                } else {
                                    // Feature branch logic
                                    if (imageExists) {
                                        needsBuild = false
                                        reason = "Image already exists for this commit"
                                    } else if (hasSignificantChanges) {
                                        needsBuild = true
                                        reason = "Files changed and image doesn't exist"
                                    } else {
                                        needsBuild = false
                                        reason = "No changes in ${app}"
                                    }
                                }
                            }

                            // Final decision
                            if (needsBuild) {
                                echo "  âœ“ [BUILD NEEDED] ${app}: ${reason}"
                                changedApps.add(app)
                                
                                // Store protection status for later use
                                if (isProtected) {
                                    env."${app}_IS_PROTECTED" = 'true'
                                }
                            } else {
                                echo "  âœ— [SKIP] ${app}: ${reason}"
                            }
                            echo ""
                        }

                        bat "docker logout ${env.DOCKER_REGISTRY}"
                    }

                    // Summary
                    echo "========================================="
                    if (changedApps.size() > 0) {
                        env.APPS_TO_BUILD = changedApps.join(',')
                        env.HAS_CHANGES = 'true'
                        echo "[RESULT] Will build ${changedApps.size()} app(s): ${env.APPS_TO_BUILD}"
                    } else {
                        env.HAS_CHANGES = 'false'
                        echo "[RESULT] No applications need building"
                    }
                    echo "========================================="
                }
            }
        }

        // ================================================================================
        // STAGE 5: Build Docker Images
        // ================================================================================
        stage('Build Docker Images') {
            when {
                environment name: 'HAS_CHANGES', value: 'true'
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> DOCKER BUILD"
                    echo "========================================="

                    def apps = env.APPS_TO_BUILD.split(',')
                    def buildJobs = [:]
                    def productionVersions = groovy.json.JsonSlurper().parseText(env.PRODUCTION_VERSIONS)

                    apps.each { app ->
                        buildJobs[app] = {
                            echo "[BUILD START] ${app}"

                            def imageTag = ''
                            def version = ''
                            def shouldTagLatest = false

                            if (env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                version = readFile("${app}/version.txt").trim()
                                imageTag = version
                                
                                // Check if this is a protected version
                                def isProtected = productionVersions.containsKey(app) && productionVersions[app] == version
                                
                                // Only tag as latest if:
                                // 1. It's not a protected version, OR
                                // 2. Protection is overridden
                                shouldTagLatest = !isProtected || params.OVERRIDE_PROTECTION
                                
                                if (isProtected && !shouldTagLatest) {
                                    echo "[PROTECTION] Will NOT update 'latest' tag for protected version ${version}"
                                }
                            } else {
                                def cleanBranchName = env.GIT_BRANCH_NAME
                                    .replaceAll('[^a-zA-Z0-9._-]', '-')
                                    .toLowerCase()
                                imageTag = "${cleanBranchName}-${env.GIT_COMMIT_SHORT}"
                                version = imageTag
                                shouldTagLatest = false  // Never tag latest for dev builds
                            }

                            def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"

                            // Sanitize commit message for Docker label
                            def sanitizedMsg = env.GIT_COMMIT_MSG
                                .replaceAll('["\\\\]', '')
                                .replaceAll('[\r\n]+', ' ')
                                .take(100)

                            try {
                                // Build Docker image with all required labels
                                def buildCommand = """docker build -t ${imageName}:${imageTag} ^
                                    --label "jenkins.build.number=${BUILD_NUMBER}" ^
                                    --label "git.commit.id=${env.GIT_COMMIT_HASH}" ^
                                    --label "git.commit.author=${env.GIT_AUTHOR}" ^
                                    --label "git.branch=${env.GIT_BRANCH_NAME}" ^
                                    --label "app.version=${version}" ^
                                    --label "build.timestamp=${env.TIMESTAMP}" ^
                                    --label "jenkins.job.name=${env.JOB_NAME}" ^
                                    --label "jenkins.build.url=${env.JENKINS_URL}job/${env.JOB_NAME}/${BUILD_NUMBER}/" ^
                                    --label "app.name=${app}" ^
                                    --label "production.protected=${env."${app}_IS_PROTECTED" ?: 'false'}" ^
                                    -f ${app}/Dockerfile ${app}/"""

                                bat buildCommand.replaceAll('\n', ' ')

                                echo "[BUILD SUCCESS] ${app}: ${imageName}:${imageTag}"

                                // Tag as latest only if appropriate
                                if (shouldTagLatest && env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                    bat "docker tag ${imageName}:${imageTag} ${imageName}:latest"
                                    echo "[TAG] Also tagged as ${imageName}:latest"
                                    writeFile file: "${app}_tags.txt", text: "${imageTag},latest"
                                } else {
                                    writeFile file: "${app}_tags.txt", text: "${imageTag}"
                                }

                            } catch (Exception e) {
                                echo "[BUILD ERROR] ${app}: ${e.message}"
                                throw e
                            }
                        }
                    }

                    parallel buildJobs
                    env.BUILD_COMPLETE = 'true'
                }
            }
        }

        // ================================================================================
        // STAGE 6: Push to Artifactory
        // ================================================================================
        stage('Push to Artifactory') {
            when {
                environment name: 'BUILD_COMPLETE', value: 'true'
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> ARTIFACTORY PUSH"
                    echo "========================================="

                    def apps = env.APPS_TO_BUILD.split(',')
                    def productionVersions = groovy.json.JsonSlurper().parseText(env.PRODUCTION_VERSIONS)

                    withCredentials([usernamePassword(
                        credentialsId: 'artifactory-credentials',
                        usernameVariable: 'ARTIFACTORY_USER',
                        passwordVariable: 'ARTIFACTORY_PASS'
                    )]) {
                        bat "echo %ARTIFACTORY_PASS% | docker login %DOCKER_REGISTRY% -u %ARTIFACTORY_USER% --password-stdin"

                        def pushJobs = [:]

                        apps.each { app ->
                            pushJobs[app] = {
                                def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"
                                def tags = readFile("${app}_tags.txt").trim().split(',')
                                
                                // Check protection status
                                def version = readFile("${app}/version.txt").trim()
                                def isProtected = productionVersions.containsKey(app) && productionVersions[app] == version

                                tags.each { tag ->
                                    try {
                                        if (tag == 'latest' && isProtected && !params.OVERRIDE_PROTECTION) {
                                            echo "[SKIP PUSH] Not pushing 'latest' tag for protected version"
                                        } else {
                                            bat "docker push ${imageName}:${tag}"
                                            echo "[PUSH SUCCESS] ${app}: ${imageName}:${tag}"
                                        }
                                    } catch (Exception e) {
                                        echo "[PUSH ERROR] ${app}:${tag}: ${e.message}"
                                        throw e
                                    }
                                }

                                // Create and upload build manifest
                                createBuildManifest(app, tags[0], isProtected)

                                env."${app}_PUSHED_TAGS" = tags.join(',')
                            }
                        }

                        parallel pushJobs
                    }

                    bat "docker logout ${env.DOCKER_REGISTRY}"
                }
            }
        }

        // ================================================================================
        // STAGE 7: Summary
        // ================================================================================
        stage('Summary') {
            steps {
                script {
                    echo "\n========================================="
                    echo ">>> BUILD SUMMARY"
                    echo "========================================="
                    echo "Branch: ${env.GIT_BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT_SHORT}"
                    echo "Author: ${env.GIT_AUTHOR}"
                    echo "Build #: ${env.BUILD_NUMBER}"
                    echo "Deploy Path: ${env.DEPLOY_PATH}"

                    def productionVersions = groovy.json.JsonSlurper().parseText(env.PRODUCTION_VERSIONS)

                    if (env.NO_APPS == 'true') {
                        echo "\n[STATUS] No applications found"
                    } else if (env.VALIDATION_FAILED == 'true') {
                        echo "\n[STATUS] Validation failed"
                    } else if (env.HAS_CHANGES == 'true') {
                        echo "\n>>> APPLICATIONS BUILT AND PUSHED:"
                        def apps = env.APPS_TO_BUILD.split(',')
                        apps.each { app ->
                            def pushedTags = env."${app}_PUSHED_TAGS"
                            def version = readFile("${app}/version.txt").trim()
                            def isProtected = productionVersions.containsKey(app) && productionVersions[app] == version
                            
                            echo "\n  ${app}${isProtected ? ' ðŸ”’ (PROTECTED)' : ''}:"
                            pushedTags.split(',').each { tag ->
                                if (tag == 'latest' && isProtected && !params.OVERRIDE_PROTECTION) {
                                    echo "    â€¢ ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}:${tag} (NOT UPDATED - PROTECTED)"
                                } else {
                                    echo "    â€¢ ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}:${tag}"
                                }
                            }
                        }

                        echo "\n>>> TO PULL IMAGES:"
                        apps.each { app ->
                            def pushedTags = env."${app}_PUSHED_TAGS"
                            pushedTags.split(',').each { tag ->
                                echo "  docker pull ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}:${tag}"
                            }
                        }
                        
                        // Show protection notice if any protected versions were involved
                        def protectedApps = apps.findAll { app ->
                            def version = readFile("${app}/version.txt").trim()
                            productionVersions.containsKey(app) && productionVersions[app] == version
                        }
                        
                        if (protectedApps.size() > 0) {
                            echo "\n>>> PROTECTION NOTICE:"
                            echo "The following apps have protected production versions:"
                            protectedApps.each { app ->
                                echo "  â€¢ ${app}: ${productionVersions[app]}"
                            }
                            if (!params.OVERRIDE_PROTECTION) {
                                echo "  'latest' tags were NOT updated for these versions."
                                echo "  Use Jenkinsfile.deploy to manage production 'latest' tags."
                            } else {
                                echo "  âš ï¸ Protection was OVERRIDDEN - 'latest' tags were updated."
                            }
                        }
                    } else {
                        echo "\n[STATUS] No changes detected"
                    }

                    echo "========================================="

                    // Update build description
                    if (env.HAS_CHANGES == 'true') {
                        def protectionStatus = params.OVERRIDE_PROTECTION ? " [OVERRIDE]" : ""
                        currentBuild.description = "${env.DEPLOY_PATH} | ${env.GIT_BRANCH_NAME} | ${env.APPS_TO_BUILD}${protectionStatus}"
                    } else if (env.NO_APPS == 'true') {
                        currentBuild.description = "No apps found | ${env.GIT_BRANCH_NAME}"
                    } else {
                        currentBuild.description = "No changes | ${env.GIT_BRANCH_NAME}"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo "[CLEANUP] Starting post-build cleanup..."

                try {
                    // Remove temporary files
                    bat "del /Q *_tags.txt 2>nul || exit 0"

                    // Clean up Docker images
                    if (env.APPS_TO_BUILD) {
                        def apps = env.APPS_TO_BUILD.split(',')
                        apps.each { app ->
                            def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"
                            bat """
                                for /f "tokens=*" %%i in ('docker images ${imageName} -q 2^>nul') do docker rmi -f %%i 2>nul || exit 0
                            """
                        }
                    }

                    // Prune system
                    bat "docker image prune -f 2>nul || exit 0"
                    bat "docker builder prune -f --filter \"until=168h\" 2>nul || exit 0"

                } catch (Exception e) {
                    echo "[CLEANUP ERROR] ${e.message}"
                }

                deleteDir()
            }
        }
        success {
            script {
                echo "[SUCCESS] Pipeline executed successfully!"

                def successMessage = "Build completed successfully"
                def details = ""

                if (env.HAS_CHANGES == 'true') {
                    def apps = env.APPS_TO_BUILD?.split(',') ?: []
                    details = "Built ${apps.size()} app(s): ${apps.join(', ')}"
                    
                    if (params.OVERRIDE_PROTECTION) {
                        details += " (PROTECTION OVERRIDDEN)"
                    }
                } else {
                    details = "No changes detected"
                }

                if (params.NOTIFY_ON_SUCCESS) {
                    sendNotification('SUCCESS', successMessage, details)
                }
            }
        }
        failure {
            script {
                echo "[FAILURE] Pipeline failed!"

                def failureReason = "Build failed"
                if (env.VALIDATION_FAILED == 'true') {
                    failureReason = "Application validation failed"
                } else if (env.NO_APPS == 'true') {
                    failureReason = "No applications found"
                }

                sendNotification('FAILURE', failureReason, "Check build logs for details")
            }
        }
    }
}

// ================================================================================
// HELPER FUNCTIONS
// ================================================================================

// Send notifications
def sendNotification(status, message, details = '') {
    try {
        def color = status == 'SUCCESS' ? 'good' : (status == 'FAILURE' ? 'danger' : 'warning')
        def emoji = status == 'SUCCESS' ? 'âœ…' : (status == 'FAILURE' ? 'âŒ' : 'âš ï¸')

        def buildUrl = "${env.JENKINS_URL}job/${env.JOB_NAME}/${BUILD_NUMBER}/"
        def gitInfo = "${env.GIT_BRANCH_NAME} (${env.GIT_COMMIT_SHORT})"

        def slackMessage = """
${emoji} *Jenkins Build ${status}*
*Job:* ${env.JOB_NAME} #${BUILD_NUMBER}
*Branch:* ${gitInfo}
*Message:* ${message}
${details ? "*Details:* ${details}" : ""}
*Build URL:* ${buildUrl}
        """.trim()

        if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
            echo "ðŸ“¢ Sending Slack notification: ${status}"

            def payload = groovy.json.JsonOutput.toJson([
                text: slackMessage,
                color: color,
                username: "Jenkins CI/CD",
                icon_emoji: ":jenkins:"
            ])

            bat """
                @curl -s -X POST -H "Content-type: application/json" ^
                     --data "${payload.replace('"', '\\"')}" ^
                     "${params.SLACK_WEBHOOK_URL}" || echo "Slack notification failed"
            """
        }

        echo "ðŸ“¢ Notification sent: ${status} - ${message}"

    } catch (Exception e) {
        echo "âš ï¸ Failed to send notification: ${e.message}"
    }
}

// Enhanced change detection function (Git-based, avoids deprecated commands)
def checkAppChangedFiles(appDir) {
    try {
        def changedFiles = []
        def changeDetectionMethod = "unknown"

        echo "    ðŸ” Detecting changes for ${appDir}..."

        // Primary Method: Git diff (most reliable, avoids deprecated commands)
        def compareCommit = env.GIT_PREVIOUS_COMMIT
        
        // Try to get previous commit if not set
        if (!compareCommit || compareCommit == "") {
            try {
                // First try to get the last successful build's commit
                def lastSuccessfulCommit = ''
                if (currentBuild.previousSuccessfulBuild) {
                    try {
                        def prevBuildEnv = currentBuild.previousSuccessfulBuild.getBuildVariables()
                        lastSuccessfulCommit = prevBuildEnv.get('GIT_COMMIT_HASH', '')
                        if (lastSuccessfulCommit && lastSuccessfulCommit != env.GIT_COMMIT_HASH) {
                            compareCommit = lastSuccessfulCommit
                            echo "    ðŸ“ Using last successful build commit: ${compareCommit.take(8)}"
                        }
                    } catch (Exception e) {
                        // Fallback to HEAD~1
                    }
                }
                
                // If still no commit, use HEAD~1
                if (!compareCommit || compareCommit == "") {
                    compareCommit = bat(
                        script: "@git rev-parse HEAD~1 2>nul || echo \"\"",
                        returnStdout: true
                    ).trim()
                    if (compareCommit) {
                        echo "    ðŸ“ Using HEAD~1 as comparison: ${compareCommit.take(8)}"
                    }
                }
            } catch (Exception e) {
                echo "    âš  Could not determine previous commit: ${e.message}"
            }
        }

        if (compareCommit && compareCommit != "") {
            echo "    ðŸ”„ Comparing ${compareCommit.take(8)}...HEAD for ${appDir}/"
            changeDetectionMethod = "git-diff"

            // Use git diff to detect changes
            def diffOutput = bat(
                script: "@git diff --name-only ${compareCommit}...HEAD -- ${appDir}/ 2>nul || echo \"\"",
                returnStdout: true
            ).trim()

            if (diffOutput) {
                diffOutput.split('\r?\n').each { file ->
                    if (file && file.trim()) {
                        changedFiles.add(file)
                        echo "      ðŸ“„ Changed: ${file}"
                    }
                }
            }

            if (changedFiles.size() > 0) {
                echo "    âœ… Found ${changedFiles.size()} changed files via git diff"
                return [files: changedFiles, method: changeDetectionMethod]
            } else {
                echo "    âœ… No files changed since ${compareCommit.take(8)}"
                return [files: [], method: changeDetectionMethod]
            }
        } else {
            // No previous commit - check if this is a new app
            echo "    ðŸ†• No previous commit found - checking if app is new..."
            
            // Check if the app directory exists and has files
            def appExists = fileExists(appDir)
            if (appExists) {
                // List all files in the app directory
                def filesInApp = bat(
                    script: "@dir /b /s ${appDir} 2>nul | find /c /v \"\" || echo 0",
                    returnStdout: true
                ).trim()
                
                if (filesInApp != "0") {
                    echo "    ðŸ†• App exists with ${filesInApp} files - treating as new/first build"
                    changeDetectionMethod = "first-build"
                    return [files: [], method: changeDetectionMethod, firstBuild: true]
                }
            }
        }

        echo "    â„¹ï¸ No changes detected or unable to determine changes"
        return [files: [], method: "no-changes", firstBuild: false]

    } catch (Exception e) {
        echo "    âŒ Error detecting changes: ${e.message}"
        // On error, assume changes exist to be safe
        return [files: [], method: "error", error: e.message, firstBuild: true]
    }
}

// Create and upload build manifest with protection status
def createBuildManifest(appName, version, isProtected = false) {
    def manifestPath = env.DEPLOY_PATH == env.DOCKER_LATEST_PATH ?
        env.BUILD_MANIFESTS_PATH : env.TEMP_BUILDS_PATH

    def manifest = [
        app: appName,
        version: version,
        build_number: env.BUILD_NUMBER,
        timestamp: env.TIMESTAMP,
        git_commit: env.GIT_COMMIT_HASH,
        git_branch: env.GIT_BRANCH_NAME,
        git_author: env.GIT_AUTHOR,
        jenkins_job: env.JOB_NAME,
        docker_image: "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${appName}:${version}",
        production_protected: isProtected,
        protection_overridden: isProtected && params.OVERRIDE_PROTECTION
    ]

    def manifestJson = groovy.json.JsonOutput.toJson(manifest)
    def manifestFile = "${appName}-${version}-manifest.json"

    writeFile file: manifestFile, text: groovy.json.JsonOutput.prettyPrint(manifestJson)

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        bat """
            curl -u %ARTIFACTORY_USER%:%ARTIFACTORY_PASS% ^
                 -T ${manifestFile} ^
                 "https://${env.DOCKER_REGISTRY}/artifactory/${env.DOCKER_REPO}/${manifestPath}/${appName}/${version}.json"
        """
    }

    echo "[MANIFEST] Uploaded ${manifestPath}/${appName}/${version}.json (protected: ${isProtected})"
}