pipeline {
    agent any

    parameters {
        string(
            name: 'BRANCH_NAME',
            defaultValue: '',
            description: 'Branch to build (leave empty for automatic detection from webhook)'
        )
        choice(
            name: 'DEPLOY_TARGET',
            choices: ['auto', 'docker-latest', 'docker-dev'],
            description: 'Where to deploy (auto = based on branch)'
        )
        booleanParam(
            name: 'FORCE_BUILD',
            defaultValue: false,
            description: 'Force rebuild even if no changes detected'
        )
        string(
            name: 'SLACK_WEBHOOK_URL',
            defaultValue: '',
            description: 'Slack webhook URL for notifications (optional)'
        )
        booleanParam(
            name: 'NOTIFY_ON_SUCCESS',
            defaultValue: false,
            description: 'Send notifications on successful builds (default: failures only)'
        )
        booleanParam(
            name: 'DRY_RUN_CLEANUP',
            defaultValue: false,
            description: 'Preview cleanup actions without actually deleting anything (for testing)'
        )
        string(
            name: 'CLEANUP_BRANCH',
            defaultValue: '',
            description: 'Clean up specific branch only (leave empty for automatic cleanup)'
        )
        string(
            name: 'FORCE_DELETE_APP',
            defaultValue: '',
            description: 'Emergency: Force delete entire app from docker-dev (use with caution)'
        )
        booleanParam(
            name: 'SKIP_CLEANUP',
            defaultValue: false,
            description: 'Skip automatic cleanup (for debugging purposes only)'
        )
    }

    triggers {
        githubPush()
    }

    environment {
        // Artifactory credentials
        ARTIFACTORY_CREDS = credentials('artifactory-credentials')

        // Build metadata
        BUILD_NUMBER = "${BUILD_NUMBER}"
        TIMESTAMP = "${new Date().format('yyyyMMdd-HHmmss')}"
        JENKINS_URL = "${env.JENKINS_URL ?: 'http://jenkins.local'}"
        JOB_NAME = "${env.JOB_NAME}"
        
        // Pipeline status flags
        NO_APPS = 'false'
        VALIDATION_FAILED = 'false'
        
        // Config values will be loaded from deployment-versions.yaml
        CONFIG_LOADED = 'false'
    }

    stages {
        // ================================================================================
        // STAGE 1: Initialize Pipeline
        // ================================================================================
        stage('Initialize') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> BUILD INITIALIZATION"
                    echo "========================================="
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "Manual Branch Override: ${params.BRANCH_NAME ?: 'none'}"
                    echo "Deploy Target: ${params.DEPLOY_TARGET}"
                    echo "Force Build: ${params.FORCE_BUILD}"
                    echo "========================================="
                    
                    // Load configuration from deployment-versions.yaml if it exists
                    if (fileExists('deployment-versions.yaml')) {
                        def deployConfig = readYaml file: 'deployment-versions.yaml'
                        
                        // Load all config values into environment
                        env.DOCKER_REGISTRY = deployConfig.config.docker_registry
                        env.DOCKER_REPO = deployConfig.config.docker_repo
                        env.DOCKER_LATEST_PATH = deployConfig.config.docker_latest_path
                        env.DOCKER_DEV_PATH = deployConfig.config.docker_dev_path
                        env.METADATA_PATH = deployConfig.config.metadata_path
                        env.BUILD_MANIFESTS_PATH = deployConfig.config.build_manifests_path
                        env.TEMP_BUILDS_PATH = deployConfig.config.temp_builds_path
                        env.DEV_RETENTION_DAYS = deployConfig.config.dev_retention_days.toString()
                        env.LATEST_VERSIONS_TO_KEEP = deployConfig.config.latest_versions_to_keep.toString()
                        
                        env.CONFIG_LOADED = 'true'
                        echo "[CONFIG] Loaded configuration from deployment-versions.yaml"
                    } else {
                        // Use default values if config file doesn't exist
                        env.DOCKER_REGISTRY = 'trialqlk1tc.jfrog.io'
                        env.DOCKER_REPO = 'dockertest-docker'
                        env.DOCKER_LATEST_PATH = 'docker-latest'
                        env.DOCKER_DEV_PATH = 'docker-dev'
                        env.METADATA_PATH = 'metadata'
                        env.BUILD_MANIFESTS_PATH = 'metadata/build-manifests'
                        env.TEMP_BUILDS_PATH = 'metadata/temporary-builds'
                        env.DEV_RETENTION_DAYS = '14'
                        env.LATEST_VERSIONS_TO_KEEP = '10'
                        
                        echo "[CONFIG] Using default configuration (deployment-versions.yaml not found)"
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 2: Checkout Code
        // ================================================================================
        stage('Checkout') {
            steps {
                script {
                    deleteDir()
                    
                    if (params.BRANCH_NAME) {
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${params.BRANCH_NAME}"]],
                            extensions: [],
                            userRemoteConfigs: scm.userRemoteConfigs
                        ])
                        env.GIT_BRANCH_NAME = params.BRANCH_NAME
                    } else {
                        checkout scm
                        
                        try {
                            env.GIT_BRANCH_NAME = bat(
                                script: '@git rev-parse --abbrev-ref HEAD',
                                returnStdout: true
                            ).trim()
                            
                            if (env.GIT_BRANCH_NAME == 'HEAD') {
                                env.GIT_BRANCH_NAME = bat(
                                    script: '@git branch -r --contains HEAD',
                                    returnStdout: true
                                ).trim()
                                env.GIT_BRANCH_NAME = env.GIT_BRANCH_NAME.replaceAll('.*origin/', '').trim()
                            }
                        } catch (Exception e) {
                            env.GIT_BRANCH_NAME = 'unknown'
                        }
                    }

                    if (env.GIT_BRANCH_NAME.contains('/')) {
                        def parts = env.GIT_BRANCH_NAME.split('/')
                        if (parts[0] == 'origin') {
                            env.GIT_BRANCH_NAME = parts[1..-1].join('/')
                        }
                    }

                    // Extract commit information
                    try {
                        env.GIT_COMMIT_HASH = bat(
                            script: '@git rev-parse HEAD',
                            returnStdout: true
                        ).trim()
                        env.GIT_COMMIT_SHORT = bat(
                            script: '@git rev-parse --short=8 HEAD',
                            returnStdout: true
                        ).trim()
                        env.GIT_COMMIT_MSG = bat(
                            script: '@git log -1 --pretty=%%B',
                            returnStdout: true
                        ).trim()
                        env.GIT_AUTHOR = bat(
                            script: '@git log -1 --pretty=%%ae',
                            returnStdout: true
                        ).trim()
                        
                        // Get previous successful commit for better change detection
                        env.GIT_PREVIOUS_COMMIT = bat(
                            script: '@git rev-parse HEAD~1 2>nul || echo ""',
                            returnStdout: true
                        ).trim()
                    } catch (Exception e) {
                        env.GIT_COMMIT_HASH = "unknown"
                        env.GIT_COMMIT_SHORT = "unknown-${BUILD_NUMBER}"
                        env.GIT_COMMIT_MSG = "Unknown"
                        env.GIT_AUTHOR = "Unknown"
                        env.GIT_PREVIOUS_COMMIT = ""
                    }

                    echo "[BRANCH] ${env.GIT_BRANCH_NAME}"
                    echo "[COMMIT] ${env.GIT_COMMIT_SHORT} (${env.GIT_COMMIT_HASH})"
                    echo "[AUTHOR] ${env.GIT_AUTHOR}"
                    
                    // Reload configuration after checkout
                    if (fileExists('deployment-versions.yaml')) {
                        def deployConfig = readYaml file: 'deployment-versions.yaml'
                        
                        // Load all config values into environment
                        env.DOCKER_REGISTRY = deployConfig.config.docker_registry
                        env.DOCKER_REPO = deployConfig.config.docker_repo
                        env.DOCKER_LATEST_PATH = deployConfig.config.docker_latest_path
                        env.DOCKER_DEV_PATH = deployConfig.config.docker_dev_path
                        env.METADATA_PATH = deployConfig.config.metadata_path
                        env.BUILD_MANIFESTS_PATH = deployConfig.config.build_manifests_path
                        env.TEMP_BUILDS_PATH = deployConfig.config.temp_builds_path
                        env.DEV_RETENTION_DAYS = deployConfig.config.dev_retention_days.toString()
                        env.LATEST_VERSIONS_TO_KEEP = deployConfig.config.latest_versions_to_keep.toString()
                        
                        env.CONFIG_LOADED = 'true'
                        echo "[CONFIG] Reloaded configuration from deployment-versions.yaml"
                    }

                    // Determine deployment path based on branch
                    if (params.DEPLOY_TARGET != 'auto') {
                        env.DEPLOY_PATH = params.DEPLOY_TARGET == 'docker-latest' ? env.DOCKER_LATEST_PATH : env.DOCKER_DEV_PATH
                    } else {
                        if (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master') {
                            env.DEPLOY_PATH = env.DOCKER_LATEST_PATH
                            echo "[DEPLOY] Main branch: using ${env.DEPLOY_PATH}"
                        } else {
                            env.DEPLOY_PATH = env.DOCKER_DEV_PATH
                            echo "[DEPLOY] Feature branch: using ${env.DEPLOY_PATH}"
                        }
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 3: Validate Applications
        // ================================================================================
        stage('Validate Applications') {
            steps {
                script {
                    echo "========================================="
                    echo ">>> MANDATORY FILE VALIDATION"
                    echo "========================================="

                    def pythonApps = []
                    def validationErrors = []

                    // Find all Dockerfiles using Windows commands
                    def dockerfiles = ''
                    try {
                        dockerfiles = bat(
                            script: '@dir /s /b Dockerfile 2>nul || echo ""',
                            returnStdout: true
                        ).trim()
                    } catch (Exception e) {
                        dockerfiles = ''
                    }

                    if (dockerfiles) {
                        dockerfiles.split('\r?\n').each { file ->
                            if (file && file.trim() && file.contains('Dockerfile')) {
                                // Convert Windows path to relative path
                                def relativePath = file.replace(env.WORKSPACE + '\\', '').replace('\\', '/')
                                def parts = relativePath.split('/')

                                // Check if Dockerfile is in a subdirectory (not root)
                                if (parts.length == 2 && parts[1] == 'Dockerfile') {
                                    def appName = parts[0]
                                    // Exclude hidden directories and jenkins directories
                                    if (!appName.startsWith('.') && !appName.startsWith('@')) {
                                        pythonApps.add(appName)
                                        echo "[FOUND] Application: ${appName}"
                                    }
                                }
                            }
                        }
                    }

                    if (pythonApps.size() == 0) {
                        env.NO_APPS = 'true'
                        env.VALIDATED_APPS = ''  // Set empty string to avoid null
                        echo "[INFO] No applications with Dockerfiles found"
                        echo "[DEBUG] Searched in: ${env.WORKSPACE}"
                        echo "[DEBUG] Raw output: ${dockerfiles}"
                        return
                    }

                    echo "[APPS] Found ${pythonApps.size()} applications: ${pythonApps.join(', ')}"

                    // Validate each application has all 4 mandatory files
                    pythonApps.each { app ->
                        echo "\n[VALIDATING] ${app}..."

                        def requiredFiles = [
                            'Dockerfile',
                            'requirements.txt',
                            'README.md',
                            'version.txt'
                        ]

                        def missingFiles = []
                        requiredFiles.each { file ->
                            def filePath = "${app}/${file}"
                            if (!fileExists(filePath)) {
                                missingFiles.add(file)
                                echo "  ❌ Missing: ${file}"
                            } else {
                                echo "  ✓ Found: ${file}"

                                // Validate version.txt format if on main branch
                                if (file == 'version.txt' && (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master')) {
                                    def version = readFile(filePath).trim()
                                    if (!version.matches('^\\d+\\.\\d+\\.\\d+$')) {
                                        validationErrors.add("${app}/version.txt has invalid format: '${version}' (expected: X.Y.Z)")
                                        echo "  ❌ Invalid version format: ${version}"
                                    } else {
                                        echo "  ✓ Version: ${version}"
                                    }
                                }
                            }
                        }

                        if (missingFiles.size() > 0) {
                            validationErrors.add("${app} is missing: ${missingFiles.join(', ')}")
                        }
                    }

                    // Fail if any validation errors
                    if (validationErrors.size() > 0) {
                        env.VALIDATION_FAILED = 'true'
                        error("""
                        ========================================
                        VALIDATION FAILED
                        ========================================
                        ${validationErrors.join('\n')}

                        All applications must contain:
                        • Dockerfile
                        • requirements.txt
                        • README.md
                        • version.txt (format: X.Y.Z)
                        ========================================
                        """)
                    } else {
                        echo "\n✅ All applications validated successfully"
                        env.VALIDATED_APPS = pythonApps.join(',')
                    }
                }
            }
        }

        // ================================================================================
        // STAGE 4: Detect Changes
        // ================================================================================
        stage('Detect Changes') {
            when {
                allOf {
                    expression { env.NO_APPS != 'true' }
                    expression { env.VALIDATION_FAILED != 'true' }
                    expression { env.VALIDATED_APPS != null && env.VALIDATED_APPS != '' }
                }
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> CHANGE DETECTION"
                    echo "========================================="

                    def pythonApps = env.VALIDATED_APPS.split(',')
                    def changedApps = []

                    // Determine if this is main branch
                    def isMainBranch = (env.GIT_BRANCH_NAME == 'main' || env.GIT_BRANCH_NAME == 'master')
                    echo "[INFO] Branch type: ${isMainBranch ? 'MAIN BRANCH' : 'FEATURE BRANCH'}"
                    echo "[INFO] Branch name: ${env.GIT_BRANCH_NAME}"
                    echo "[INFO] Detection strategy: ${isMainBranch ? 'Build if changed OR new version' : 'Build ONLY if changed'}"
                    echo ""

                    withCredentials([usernamePassword(
                        credentialsId: 'artifactory-credentials',
                        usernameVariable: 'ARTIFACTORY_USER',
                        passwordVariable: 'ARTIFACTORY_PASS'
                    )]) {
                        bat "echo %ARTIFACTORY_PASS% | docker login %DOCKER_REGISTRY% -u %ARTIFACTORY_USER% --password-stdin"

                        pythonApps.each { app ->
                            def needsBuild = false
                            def reason = ""

                            echo "[ANALYZING] ${app}..."
                            echo "  Current commit: ${env.GIT_COMMIT_SHORT}"
                            echo "  Previous commit: ${env.GIT_PREVIOUS_COMMIT ?: 'none'}"

                            // For force build, always rebuild
                            if (params.FORCE_BUILD) {
                                needsBuild = true
                                reason = "Force build requested by user"
                            } else {
                                // Check for file changes using enhanced function
                                def changeResult = checkAppChangedFiles(app)
                                def changedFiles = changeResult.files ?: []
                                def detectionMethod = changeResult.method ?: "unknown"
                                def isFirstBuild = changeResult.firstBuild ?: false

                                echo "  Detection method: ${detectionMethod}"
                                if (changeResult.error) {
                                    echo "  Detection error: ${changeResult.error}"
                                }

                                // Filter out README-only changes
                                def significantChanges = changedFiles.findAll { !it.endsWith('README.md') }
                                def hasSignificantChanges = significantChanges.size() > 0

                                // Show what changed
                                if (hasSignificantChanges) {
                                    echo "  📝 Files changed in ${app} (${significantChanges.size()} significant):"
                                    significantChanges.each { file ->
                                        echo "    - ${file}"
                                    }
                                } else if (changedFiles.size() > 0) {
                                    echo "  📝 Only README changes in ${app} (${changedFiles.size()} total files)"
                                } else {
                                    echo "  ✅ No changes detected in ${app}"
                                }

                                // Determine the image tag
                                def imageTag = ''
                                def imageName = ''

                                if (env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                    // Main branch - use version from version.txt
                                    def version = readFile("${app}/version.txt").trim()
                                    imageTag = version
                                    imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_LATEST_PATH}/${app}:${imageTag}"
                                } else {
                                    // Feature branch - use branch-commit format
                                    def cleanBranchName = env.GIT_BRANCH_NAME
                                        .replaceAll('[^a-zA-Z0-9._-]', '-')
                                        .toLowerCase()
                                    imageTag = "${cleanBranchName}-${env.GIT_COMMIT_SHORT}"
                                    imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DOCKER_DEV_PATH}/${app}:${imageTag}"
                                }

                                echo "  Image tag: ${imageTag}"

                                // Check if image already exists in Artifactory
                                def imageExists = bat(
                                    script: "docker pull ${imageName} >nul 2>&1",
                                    returnStatus: true
                                ) == 0

                                if (imageExists) {
                                    echo "  Image exists: YES"
                                    bat "docker rmi ${imageName} 2>nul || exit 0"
                                } else {
                                    echo "  Image exists: NO"
                                }

                                // ===== IMPROVED DECISION LOGIC =====
                                if (isMainBranch) {
                                    // MAIN BRANCH: Build if files changed OR image doesn't exist (new version)
                                    if (hasSignificantChanges) {
                                        needsBuild = true
                                        reason = "Files changed (${significantChanges.size()} files modified)"
                                    } else if (!imageExists) {
                                        needsBuild = true
                                        reason = "New version ${imageTag} needs to be built"
                                    } else {
                                        needsBuild = false
                                        reason = "No changes and image already exists"
                                    }
                                } else {
                                    // FEATURE BRANCH: Build if files changed AND image doesn't exist
                                    // This prevents rebuilding the same commit multiple times
                                    if (imageExists) {
                                        needsBuild = false
                                        reason = "Image already exists for this commit - skipping rebuild"
                                    } else if (hasSignificantChanges) {
                                        needsBuild = true
                                        reason = "Files changed and image doesn't exist (${significantChanges.size()} files modified)"
                                    } else {
                                        needsBuild = false
                                        reason = "No changes in ${app} - skipping build on feature branch"
                                    }
                                }
                            }

                            // Final decision
                            if (needsBuild) {
                                echo "  ✓ [BUILD NEEDED] ${app}: ${reason}"
                                changedApps.add(app)
                            } else {
                                echo "  ✗ [SKIP] ${app}: ${reason}"
                            }
                            echo ""
                        }

                        bat "docker logout ${env.DOCKER_REGISTRY}"
                    }

                    // Summary
                    echo "========================================="
                    if (changedApps.size() > 0) {
                        env.APPS_TO_BUILD = changedApps.join(',')
                        env.HAS_CHANGES = 'true'
                        echo "[RESULT] Will build ${changedApps.size()} app(s): ${env.APPS_TO_BUILD}"
                    } else {
                        env.HAS_CHANGES = 'false'
                        echo "[RESULT] No applications need building"
                    }
                    echo "========================================="
                }
            }
        }

        // ================================================================================
        // STAGE 5: Build Docker Images
        // ================================================================================
        stage('Build Docker Images') {
            when {
                environment name: 'HAS_CHANGES', value: 'true'
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> DOCKER BUILD"
                    echo "========================================="

                    def apps = env.APPS_TO_BUILD.split(',')
                    def buildJobs = [:]

                    apps.each { app ->
                        buildJobs[app] = {
                            echo "[BUILD START] ${app}"

                            def imageTag = ''
                            def version = ''

                            if (env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                // Main branch - use version from version.txt
                                version = readFile("${app}/version.txt").trim()
                                imageTag = version
                            } else {
                                // Feature branch - use branch-commit format
                                def cleanBranchName = env.GIT_BRANCH_NAME
                                    .replaceAll('[^a-zA-Z0-9._-]', '-')
                                    .toLowerCase()
                                imageTag = "${cleanBranchName}-${env.GIT_COMMIT_SHORT}"
                                version = imageTag  // For dev builds, version is the same as tag
                            }

                            def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"

                            // Sanitize commit message for Docker label
                            def sanitizedMsg = env.GIT_COMMIT_MSG
                                .replaceAll('["\\\\]', '')
                                .replaceAll('[\r\n]+', ' ')
                                .take(100)

                            try {
                                // Build Docker image with all required labels (Windows compatible)
                                def buildCommand = """docker build -t ${imageName}:${imageTag} ^
                                    --label "jenkins.build.number=${BUILD_NUMBER}" ^
                                    --label "git.commit.id=${env.GIT_COMMIT_HASH}" ^
                                    --label "git.commit.author=${env.GIT_AUTHOR}" ^
                                    --label "git.branch=${env.GIT_BRANCH_NAME}" ^
                                    --label "app.version=${version}" ^
                                    --label "build.timestamp=${env.TIMESTAMP}" ^
                                    --label "jenkins.job.name=${env.JOB_NAME}" ^
                                    --label "jenkins.build.url=${env.JENKINS_URL}job/${env.JOB_NAME}/${BUILD_NUMBER}/" ^
                                    --label "app.name=${app}" ^
                                    -f ${app}/Dockerfile ${app}/"""

                                bat buildCommand.replaceAll('\n', ' ')

                                // For main branch, also tag as latest
                                if (env.DEPLOY_PATH == env.DOCKER_LATEST_PATH) {
                                    bat "docker tag ${imageName}:${imageTag} ${imageName}:latest"
                                    echo "[TAG] Also tagged as ${imageName}:latest"
                                }

                                echo "[BUILD SUCCESS] ${app}: ${imageName}:${imageTag}"

                                // Store tags for push stage
                                writeFile file: "${app}_tags.txt", text: "${imageTag}${env.DEPLOY_PATH == env.DOCKER_LATEST_PATH ? ',latest' : ''}"

                            } catch (Exception e) {
                                echo "[BUILD ERROR] ${app}: ${e.message}"
                                throw e
                            }
                        }
                    }

                    parallel buildJobs
                    env.BUILD_COMPLETE = 'true'
                }
            }
        }

        // ================================================================================
        // STAGE 6: Push to Artifactory
        // ================================================================================
        stage('Push to Artifactory') {
            when {
                environment name: 'BUILD_COMPLETE', value: 'true'
            }
            steps {
                script {
                    echo "========================================="
                    echo ">>> ARTIFACTORY PUSH"
                    echo "========================================="

                    def apps = env.APPS_TO_BUILD.split(',')

                    withCredentials([usernamePassword(
                        credentialsId: 'artifactory-credentials',
                        usernameVariable: 'ARTIFACTORY_USER',
                        passwordVariable: 'ARTIFACTORY_PASS'
                    )]) {
                        bat "echo %ARTIFACTORY_PASS% | docker login %DOCKER_REGISTRY% -u %ARTIFACTORY_USER% --password-stdin"

                        def pushJobs = [:]

                        apps.each { app ->
                            pushJobs[app] = {
                                def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"
                                def tags = readFile("${app}_tags.txt").trim().split(',')

                                tags.each { tag ->
                                    try {
                                        bat "docker push ${imageName}:${tag}"
                                        echo "[PUSH SUCCESS] ${app}: ${imageName}:${tag}"
                                    } catch (Exception e) {
                                        echo "[PUSH ERROR] ${app}:${tag}: ${e.message}"
                                        throw e
                                    }
                                }

                                // Create and upload build manifest
                                createBuildManifest(app, tags[0])

                                env."${app}_PUSHED_TAGS" = tags.join(',')
                            }
                        }

                        parallel pushJobs
                    }

                    bat "docker logout ${env.DOCKER_REGISTRY}"
                }
            }
        }

        // ================================================================================
        // STAGE 7: Summary
        // ================================================================================
        stage('Summary') {
            steps {
                script {
                    echo "\n========================================="
                    echo ">>> BUILD SUMMARY"
                    echo "========================================="
                    echo "Branch: ${env.GIT_BRANCH_NAME}"
                    echo "Commit: ${env.GIT_COMMIT_SHORT}"
                    echo "Author: ${env.GIT_AUTHOR}"
                    echo "Build #: ${env.BUILD_NUMBER}"
                    echo "Deploy Path: ${env.DEPLOY_PATH}"

                    if (env.NO_APPS == 'true') {
                        echo "\n[STATUS] No applications found"
                        echo "Make sure you have application folders with:"
                        echo "  - Dockerfile"
                        echo "  - requirements.txt"
                        echo "  - README.md"
                        echo "  - version.txt"
                    } else if (env.VALIDATION_FAILED == 'true') {
                        echo "\n[STATUS] Validation failed"
                    } else if (env.HAS_CHANGES == 'true') {
                        echo "\n>>> APPLICATIONS BUILT AND PUSHED:"
                        def apps = env.APPS_TO_BUILD.split(',')
                        apps.each { app ->
                            def pushedTags = env."${app}_PUSHED_TAGS"
                            echo "\n  ${app}:"
                            pushedTags.split(',').each { tag ->
                                echo "    • ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}:${tag}"
                            }
                        }

                        echo "\n>>> TO PULL IMAGES:"
                        apps.each { app ->
                            def pushedTags = env."${app}_PUSHED_TAGS"
                            pushedTags.split(',').each { tag ->
                                echo "  docker pull ${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}:${tag}"
                            }
                        }
                    } else {
                        echo "\n[STATUS] No changes detected"
                    }

                    echo "========================================="

                    // Update build description
                    if (env.HAS_CHANGES == 'true') {
                        currentBuild.description = "${env.DEPLOY_PATH} | ${env.GIT_BRANCH_NAME} | ${env.APPS_TO_BUILD}"
                    } else if (env.NO_APPS == 'true') {
                        currentBuild.description = "No apps found | ${env.GIT_BRANCH_NAME}"
                    } else {
                        currentBuild.description = "No changes | ${env.GIT_BRANCH_NAME}"
                    }
                }
            }
        }
    }

    post {
        always {
            script {
                echo "[CLEANUP] Starting post-build cleanup..."

                try {
                    // Remove temporary files (Windows)
                    bat "del /Q *_tags.txt 2>nul || exit 0"

                    // Clean up Docker images
                    if (env.APPS_TO_BUILD) {
                        def apps = env.APPS_TO_BUILD.split(',')
                        apps.each { app ->
                            def imageName = "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${app}"

                            // Remove all tags for this app (Windows)
                            bat """
                                for /f "tokens=*" %%i in ('docker images ${imageName} -q 2^>nul') do docker rmi -f %%i 2>nul || exit 0
                            """
                        }
                    }

                    // Prune system
                    bat "docker image prune -f 2>nul || exit 0"
                    bat "docker builder prune -f --filter \"until=168h\" 2>nul || exit 0"

                } catch (Exception e) {
                    echo "[CLEANUP ERROR] ${e.message}"
                }

                deleteDir()
            }
        }
        success {
            script {
                echo "[SUCCESS] Pipeline executed successfully!"

                def successMessage = "Build completed successfully"
                def details = ""

                if (env.HAS_CHANGES == 'true') {
                    def apps = env.APPS_TO_BUILD?.split(',') ?: []
                    details = "Built ${apps.size()} app(s): ${apps.join(', ')}"
                } else {
                    details = "No changes detected"
                }

                if (params.NOTIFY_ON_SUCCESS) {
                    sendNotification('SUCCESS', successMessage, details)
                }

                // ================================================================================
                // AUTOMATIC ARTIFACTORY CLEANUP (runs by default after successful builds)
                // ================================================================================
                def cleanupStartTime = System.currentTimeMillis()
                def cleanupResults = [
                    success: false,
                    duration: 0,
                    devImagesDeleted: 0,
                    latestVersionsDeleted: 0,
                    manifestsDeleted: 0,
                    errors: []
                ]

                try {
                    echo "\n========================================="
                    echo ">>> ARTIFACTORY CLEANUP"
                    echo "========================================="

                    // Check if cleanup should be skipped
                    if (params.SKIP_CLEANUP) {
                        echo "[CLEANUP] ⏭️  SKIPPED - Cleanup disabled via SKIP_CLEANUP parameter"
                        echo "[CLEANUP] This is intended for debugging purposes only"
                        echo "[CLEANUP] Re-enable cleanup for production builds"
                        cleanupResults.success = true
                        return
                    }

                    echo "[CLEANUP] Starting automatic cleanup after successful build"
                    echo "[CLEANUP] Dry run mode: ${params.DRY_RUN_CLEANUP}"
                    echo "[CLEANUP] Configuration:"
                    echo "[CLEANUP]   - Keep latest ${env.LATEST_VERSIONS_TO_KEEP} versions in docker-latest"
                    echo "[CLEANUP]   - Remove dev builds older than ${env.DEV_RETENTION_DAYS} days"
                    echo "[CLEANUP]   - Docker registry: ${env.DOCKER_REGISTRY}"

                    if (params.FORCE_DELETE_APP != '') {
                        // Emergency: Force delete entire app folder
                        echo "[CLEANUP] EMERGENCY: Force deleting entire app: ${params.FORCE_DELETE_APP}"
                        forceDeleteApp(params.FORCE_DELETE_APP)
                        cleanupResults.success = true
                    } else if (params.CLEANUP_BRANCH != '') {
                        // Clean up specific branch only
                        echo "[CLEANUP] Cleaning up specific branch: ${params.CLEANUP_BRANCH}"
                        cleanupSpecificBranch(params.CLEANUP_BRANCH)
                        cleanupResults.success = true
                    } else {
                        // Default automatic cleanup - runs by default on every successful build
                        echo "[CLEANUP] Running automatic cleanup (default behavior)"
                        echo "[CLEANUP] This will clean docker-dev (orphaned branches) and docker-latest (old versions)"

                        // 1. Always clean up docker-dev repository (orphaned branches)
                        cleanupDevImages()

                        // 2. Always clean up docker-latest repository (keep last N versions per app)
                        cleanupLatestImages()

                        // 3. Always clean up metadata/temporary-builds
                        cleanupTempManifests()

                        cleanupResults.success = true
                    }

                    def cleanupEndTime = System.currentTimeMillis()
                    cleanupResults.duration = (cleanupEndTime - cleanupStartTime) / 1000

                    echo "\n========================================="
                    echo ">>> CLEANUP SUMMARY"
                    echo "========================================="
                    echo "[CLEANUP] ✅ Cleanup completed successfully"
                    echo "[CLEANUP] Duration: ${cleanupResults.duration} seconds"
                    if (params.DRY_RUN_CLEANUP) {
                        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions performed"
                        echo "[CLEANUP] Review the logs above to see what would be cleaned up"
                    } else {
                        echo "[CLEANUP] Cleanup operations completed"
                        echo "[CLEANUP] Check individual function logs for detailed results"
                    }
                    echo "========================================="

                    // Update build description to include cleanup info
                    if (env.HAS_CHANGES == 'true') {
                        def cleanupStatus = params.DRY_RUN_CLEANUP ? " | Cleanup: DRY RUN" : " | Cleanup: ✅"
                        currentBuild.description = "${env.DEPLOY_PATH} | ${env.GIT_BRANCH_NAME} | ${env.APPS_TO_BUILD}${cleanupStatus}"
                    }

                } catch (Exception e) {
                    def cleanupEndTime = System.currentTimeMillis()
                    cleanupResults.duration = (cleanupEndTime - cleanupStartTime) / 1000
                    cleanupResults.errors.add(e.message)

                    echo "\n========================================="
                    echo ">>> CLEANUP ERROR"
                    echo "========================================="
                    echo "[CLEANUP ERROR] ❌ Cleanup failed but build was successful"
                    echo "[CLEANUP ERROR] Error: ${e.message}"
                    echo "[CLEANUP ERROR] Duration: ${cleanupResults.duration} seconds"
                    echo "[CLEANUP ERROR] This error does not affect the main build result"
                    echo "========================================="

                    // Update build description to show cleanup error
                    if (env.HAS_CHANGES == 'true') {
                        currentBuild.description = "${env.DEPLOY_PATH} | ${env.GIT_BRANCH_NAME} | ${env.APPS_TO_BUILD} | Cleanup: ❌"
                    }

                    // Don't fail the build due to cleanup errors
                }
            }
        }
        failure {
            script {
                echo "[FAILURE] Pipeline failed!"

                def failureReason = "Build failed"
                if (env.VALIDATION_FAILED == 'true') {
                    failureReason = "Application validation failed"
                } else if (env.NO_APPS == 'true') {
                    failureReason = "No applications found"
                }

                sendNotification('FAILURE', failureReason, "Check build logs for details")
            }
        }
    }
}

// ================================================================================
// HELPER FUNCTIONS
// ================================================================================

// Robust HTTP call with retry logic and proper error handling
def makeHttpCall(url, method = 'GET', maxRetries = 3, retryDelay = 5) {
    def attempt = 0
    def lastError = null

    while (attempt < maxRetries) {
        attempt++
        try {
            echo "    🌐 HTTP ${method} attempt ${attempt}/${maxRetries}: ${url}"

            def curlCommand = ""
            if (method == 'DELETE') {
                curlCommand = "@curl -s -w \"HTTPSTATUS:%%{http_code}\" -u \"%ARTIFACTORY_USER%:%ARTIFACTORY_PASS%\" -X ${method} \"${url}\""
            } else if (method == 'POST') {
                curlCommand = "@curl -s -w \"HTTPSTATUS:%%{http_code}\" -u \"%ARTIFACTORY_USER%:%ARTIFACTORY_PASS%\" -X POST -H \"Content-Type: text/plain\" --data-binary \"@-\" \"${url}\""
            } else {
                curlCommand = "@curl -s -w \"HTTPSTATUS:%%{http_code}\" -u \"%ARTIFACTORY_USER%:%ARTIFACTORY_PASS%\" \"${url}\""
            }

            def response = bat(
                script: curlCommand,
                returnStdout: true
            ).trim()

            def httpStatus = response.contains('HTTPSTATUS:') ?
                response.split('HTTPSTATUS:')[1] : '000'
            def responseBody = response.contains('HTTPSTATUS:') ?
                response.split('HTTPSTATUS:')[0] : response

            // Check if this is a successful response
            if (httpStatus.startsWith('2')) {
                echo "    ✅ HTTP ${method} success: ${httpStatus}"
                return [
                    success: true,
                    httpStatus: httpStatus,
                    response: responseBody,
                    attempt: attempt
                ]
            } else if (httpStatus == '404') {
                // 404 for DELETE means file was already deleted or doesn't exist
                if (method == 'DELETE') {
                    echo "    ℹ️ HTTP ${method} file not found: ${httpStatus} (already deleted or doesn't exist)"
                    return [
                        success: true,
                        httpStatus: httpStatus,
                        response: responseBody,
                        attempt: attempt,
                        alreadyDeleted: true
                    ]
                } else {
                    echo "    ❌ HTTP ${method} not found: ${httpStatus}"
                    return [
                        success: false,
                        httpStatus: httpStatus,
                        response: responseBody,
                        attempt: attempt,
                        error: "Resource not found (${httpStatus})"
                    ]
                }
            }
            } else if (httpStatus == '401' || httpStatus == '403') {
                // Authentication/authorization error - don't retry
                echo "    ❌ HTTP ${method} authentication error: ${httpStatus}"
                return [
                    success: false,
                    httpStatus: httpStatus,
                    response: responseBody,
                    attempt: attempt,
                    error: "Authentication failed (${httpStatus}). Check Artifactory credentials."
                ]
            } else if (httpStatus == '429' && attempt < maxRetries) {
                // Rate limit - retry with longer delay
                def rateLimitDelay = retryDelay * 2
                echo "    ⚠ HTTP ${method} rate limited: ${httpStatus} - retrying in ${rateLimitDelay}s"
                sleep(rateLimitDelay)
                lastError = "HTTP ${httpStatus}: Rate limited"
                continue
            } else if (httpStatus.startsWith('5') && attempt < maxRetries) {
                // Server error - retry
                echo "    ⚠ HTTP ${method} server error: ${httpStatus} - retrying in ${retryDelay}s"
                sleep(retryDelay)
                lastError = "HTTP ${httpStatus}: ${responseBody}"
                continue
            } else {
                // Client error or final attempt - don't retry
                echo "    ❌ HTTP ${method} failed: ${httpStatus}"
                def errorMsg = "HTTP ${httpStatus}"
                if (httpStatus == '400') {
                    errorMsg += ": Bad request - check API parameters"
                } else if (httpStatus == '404') {
                    errorMsg += ": Resource not found"
                } else if (httpStatus.startsWith('5')) {
                    errorMsg += ": Server error - Artifactory may be temporarily unavailable"
                }

                return [
                    success: false,
                    httpStatus: httpStatus,
                    response: responseBody,
                    attempt: attempt,
                    error: "${errorMsg}: ${responseBody}"
                ]
            }
        } catch (Exception e) {
            lastError = e.message
            echo "    ❌ HTTP ${method} exception on attempt ${attempt}: ${e.message}"

            if (attempt < maxRetries) {
                echo "    ⏳ Retrying in ${retryDelay} seconds..."
                sleep(retryDelay)
            }
        }
    }

    // All attempts failed
    return [
        success: false,
        httpStatus: '000',
        response: '',
        attempt: attempt,
        error: "All ${maxRetries} attempts failed. Last error: ${lastError}"
    ]
}

// Send notifications (Slack, email, etc.)
def sendNotification(status, message, details = '') {
    try {
        def color = status == 'SUCCESS' ? 'good' : (status == 'FAILURE' ? 'danger' : 'warning')
        def emoji = status == 'SUCCESS' ? '✅' : (status == 'FAILURE' ? '❌' : '⚠️')

        def buildUrl = "${env.JENKINS_URL}job/${env.JOB_NAME}/${BUILD_NUMBER}/"
        def gitInfo = "${env.GIT_BRANCH_NAME} (${env.GIT_COMMIT_SHORT})"

        def slackMessage = """
${emoji} *Jenkins Build ${status}*
*Job:* ${env.JOB_NAME} #${BUILD_NUMBER}
*Branch:* ${gitInfo}
*Message:* ${message}
${details ? "*Details:* ${details}" : ""}
*Build URL:* ${buildUrl}
        """.trim()

        // Send Slack notification if webhook URL is provided
        if (params.SLACK_WEBHOOK_URL && params.SLACK_WEBHOOK_URL.trim()) {
            echo "📢 Sending Slack notification: ${status}"

            def payload = groovy.json.JsonOutput.toJson([
                text: slackMessage,
                color: color,
                username: "Jenkins CI/CD",
                icon_emoji: ":jenkins:"
            ])

            bat """
                @curl -s -X POST -H "Content-type: application/json" ^
                     --data "${payload.replace('"', '\\"')}" ^
                     "${params.SLACK_WEBHOOK_URL}" || echo "Slack notification failed"
            """
        }

        // Log notification for debugging
        echo "📢 Notification sent: ${status} - ${message}"

    } catch (Exception e) {
        echo "⚠️ Failed to send notification: ${e.message}"
    }
}

// Enhanced change detection function with multiple strategies
def checkAppChangedFiles(appDir) {
    try {
        def changedFiles = []
        def changeDetectionMethod = "unknown"

        echo "    🔍 Detecting changes for ${appDir}..."

        // Method 1: Jenkins changeset information (most reliable for webhooks)
        if (currentBuild.changeSets && currentBuild.changeSets.size() > 0) {
            echo "    📋 Using Jenkins changeset information"
            changeDetectionMethod = "jenkins-changeset"

            currentBuild.changeSets.each { changeSet ->
                changeSet.items.each { change ->
                    change.affectedFiles.each { file ->
                        if (file.path.startsWith("${appDir}/")) {
                            changedFiles.add(file.path)
                            echo "      📄 Changed: ${file.path} (${file.editType})"
                        }
                    }
                }
            }

            if (changedFiles.size() > 0) {
                echo "    ✅ Found ${changedFiles.size()} changed files via Jenkins changeset"
                return [files: changedFiles, method: changeDetectionMethod]
            }
        }

        // Method 2: Git diff with improved commit detection
        def compareCommit = env.GIT_PREVIOUS_COMMIT
        if (!compareCommit || compareCommit == "") {
            // Try to get the previous commit from the same branch
            try {
                compareCommit = bat(
                    script: "@git rev-parse HEAD~1 2>nul || echo \"\"",
                    returnStdout: true
                ).trim()
                echo "    📍 Using HEAD~1 as comparison: ${compareCommit}"
            } catch (Exception e) {
                echo "    ⚠ Could not determine previous commit: ${e.message}"
            }
        }

        if (compareCommit && compareCommit != "") {
            echo "    🔄 Comparing ${compareCommit}...HEAD for ${appDir}/"
            changeDetectionMethod = "git-diff"

            def diffOutput = bat(
                script: "@git diff --name-only ${compareCommit}...HEAD -- ${appDir}/ 2>nul || echo \"\"",
                returnStdout: true
            ).trim()

            if (diffOutput) {
                diffOutput.split('\r?\n').each { file ->
                    if (file && file.trim()) {
                        changedFiles.add(file)
                        echo "      📄 Changed: ${file}"
                    }
                }
            }

            if (changedFiles.size() > 0) {
                echo "    ✅ Found ${changedFiles.size()} changed files via git diff"
                return [files: changedFiles, method: changeDetectionMethod]
            } else {
                echo "    ✅ No files changed since ${compareCommit}"
                return [files: [], method: changeDetectionMethod]
            }
        }

        // Method 3: Check if this is a completely new app (no previous builds)
        echo "    🆕 First build or no previous commit - checking if app exists in registry"
        changeDetectionMethod = "first-build"

        // Return empty files but indicate this is a first build
        return [files: [], method: changeDetectionMethod, firstBuild: true]

    } catch (Exception e) {
        echo "    ❌ Error detecting changes: ${e.message}"
        // Return safe default - empty files, let image existence check decide
        return [files: [], method: "error", error: e.message]
    }
}

// Create and upload build manifest (Windows compatible)
def createBuildManifest(appName, version) {
    def manifestPath = env.DEPLOY_PATH == env.DOCKER_LATEST_PATH ?
        env.BUILD_MANIFESTS_PATH : env.TEMP_BUILDS_PATH

    def manifest = [
        app: appName,
        version: version,
        build_number: env.BUILD_NUMBER,
        timestamp: env.TIMESTAMP,
        git_commit: env.GIT_COMMIT_HASH,
        git_branch: env.GIT_BRANCH_NAME,
        git_author: env.GIT_AUTHOR,
        jenkins_job: env.JOB_NAME,
        docker_image: "${env.DOCKER_REGISTRY}/${env.DOCKER_REPO}/${env.DEPLOY_PATH}/${appName}:${version}"
    ]

    def manifestJson = groovy.json.JsonOutput.toJson(manifest)
    def manifestFile = "${appName}-${version}-manifest.json"

    writeFile file: manifestFile, text: groovy.json.JsonOutput.prettyPrint(manifestJson)

    // Upload manifest to Artifactory (Windows curl)
    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        bat """
            curl -u %ARTIFACTORY_USER%:%ARTIFACTORY_PASS% ^
                 -T ${manifestFile} ^
                 "https://${env.DOCKER_REGISTRY}/artifactory/${env.DOCKER_REPO}/${manifestPath}/${appName}/${version}.json"
        """
    }

    echo "[MANIFEST] Uploaded ${manifestPath}/${appName}/${version}.json"
}

// Recovery function for handling partial cleanup failures
def handleCleanupError(operation, error, continueOnError = true) {
    echo "[CLEANUP ERROR] ❌ ${operation} failed: ${error}"

    // Log error details for troubleshooting
    if (error.contains('401') || error.contains('403')) {
        echo "[CLEANUP ERROR] 🔐 Authentication issue detected"
        echo "[CLEANUP ERROR] Verify Artifactory credentials are valid and have sufficient permissions"
        echo "[CLEANUP ERROR] Required permissions: DELETE, READ on repository ${env.DOCKER_REPO}"
    } else if (error.contains('429')) {
        echo "[CLEANUP ERROR] 🚦 Rate limiting detected"
        echo "[CLEANUP ERROR] Artifactory is rate limiting requests - consider reducing cleanup frequency"
    } else if (error.contains('5')) {
        echo "[CLEANUP ERROR] 🌐 Server error detected"
        echo "[CLEANUP ERROR] Artifactory server may be temporarily unavailable"
        echo "[CLEANUP ERROR] This is usually temporary - cleanup will retry on next build"
    } else if (error.contains('timeout') || error.contains('connection')) {
        echo "[CLEANUP ERROR] 🔌 Network connectivity issue"
        echo "[CLEANUP ERROR] Check network connection to ${env.DOCKER_REGISTRY}"
    }

    if (!continueOnError) {
        throw new Exception("Critical cleanup error: ${error}")
    }

    echo "[CLEANUP ERROR] ⏭️  Continuing with remaining cleanup operations..."
    return false
}

// ================================================================================
// ARTIFACTORY QUERY LANGUAGE (AQL) FUNCTIONS
// ================================================================================

// Execute AQL (Artifactory Query Language) query
def executeAQL(aqlQuery, maxRetries = 3) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/api/search/aql"

    try {
        echo "    🔍 Executing AQL query..."
        echo "    Query: ${aqlQuery.take(100)}${aqlQuery.length() > 100 ? '...' : ''}"

        // Write AQL query to temporary file for curl
        def tempFile = "aql_query_${System.currentTimeMillis()}.txt"
        writeFile file: tempFile, text: aqlQuery

        def curlCommand = "@curl -s -w \"HTTPSTATUS:%%{http_code}\" -u \"%ARTIFACTORY_USER%:%ARTIFACTORY_PASS%\" -X POST -H \"Content-Type: text/plain\" --data-binary \"@${tempFile}\" \"${url}\""

        def response = bat(
            script: curlCommand,
            returnStdout: true
        ).trim()

        // Clean up temp file
        bat "del /Q ${tempFile} 2>nul || exit 0"

        def httpStatus = response.contains('HTTPSTATUS:') ?
            response.split('HTTPSTATUS:')[1] : '000'
        def responseBody = response.contains('HTTPSTATUS:') ?
            response.split('HTTPSTATUS:')[0] : response

        if (httpStatus.startsWith('2')) {
            def jsonResponse = readJSON text: responseBody
            return [
                success: true,
                results: jsonResponse.results ?: [],
                range: jsonResponse.range ?: [:]
            ]
        } else {
            return [
                success: false,
                error: "AQL query failed with HTTP ${httpStatus}: ${responseBody}"
            ]
        }

    } catch (Exception e) {
        return [
            success: false,
            error: "AQL query exception: ${e.message}"
        ]
    }
}

// Get Docker images using AQL (more efficient than REST API)
def getDockerImagesAQL(repositoryPath, appName = null) {
    def pathPattern = repositoryPath + (appName ? '/' + appName : '/*')
    def aqlQuery = """items.find({
    "repo": "${env.DOCKER_REPO}",
    "path": {"\$match": "${pathPattern}"},
    "name": {"\$match": "manifest.json"}
}).include("path", "name", "created", "size")"""

    def result = executeAQL(aqlQuery)

    if (result.success) {
        def images = [:]
        result.results.each { item ->
            // Extract app and tag from path: docker-dev/myapp/v1.0.0/manifests/latest/manifest.json
            def pathParts = item.path.split('/')
            if (pathParts.length >= 3) {
                def app = pathParts[1]
                def tag = pathParts[2]

                if (!images[app]) {
                    images[app] = []
                }
                images[app].add([
                    tag: tag,
                    created: item.created,
                    size: item.size
                ])
            }
        }

        return [success: true, images: images]
    } else {
        return result
    }
}

// Get metadata files using AQL
def getMetadataFilesAQL(metadataPath) {
    def pathPattern = metadataPath + "/*"
    def aqlQuery = """items.find({
    "repo": "${env.DOCKER_REPO}",
    "path": {"\$match": "${pathPattern}"},
    "name": {"\$match": "*.json"}
}).include("path", "name", "created", "size")"""

    def result = executeAQL(aqlQuery)

    if (result.success) {
        def metadata = [:]
        result.results.each { item ->
            // Extract app from path: metadata/temporary-builds/myapp/branch-commit.json
            def pathParts = item.path.split('/')
            if (pathParts.length >= 3) {
                def app = pathParts[2]

                if (!metadata[app]) {
                    metadata[app] = []
                }
                metadata[app].add([
                    filename: item.name,
                    created: item.created,
                    size: item.size,
                    fullPath: "${item.path}/${item.name}"
                ])
            }
        }

        return [success: true, metadata: metadata]
    } else {
        return result
    }
}

// ================================================================================
// CLEANUP VALIDATION AND TESTING FUNCTIONS
// ================================================================================

// Validate cleanup configuration before running
def validateCleanupConfig() {
    echo "[CLEANUP] Validating cleanup configuration..."

    def errors = []

    // Check required environment variables
    if (!env.DOCKER_REGISTRY) {
        errors.add("DOCKER_REGISTRY not configured")
    }
    if (!env.DOCKER_REPO) {
        errors.add("DOCKER_REPO not configured")
    }
    if (!env.DOCKER_LATEST_PATH) {
        errors.add("DOCKER_LATEST_PATH not configured")
    }
    if (!env.DOCKER_DEV_PATH) {
        errors.add("DOCKER_DEV_PATH not configured")
    }
    if (!env.TEMP_BUILDS_PATH) {
        errors.add("TEMP_BUILDS_PATH not configured")
    }
    if (!env.BUILD_MANIFESTS_PATH) {
        errors.add("BUILD_MANIFESTS_PATH not configured")
    }

    // Check numeric configurations
    try {
        def versionsToKeep = Integer.parseInt(env.LATEST_VERSIONS_TO_KEEP ?: '0')
        if (versionsToKeep <= 0) {
            errors.add("LATEST_VERSIONS_TO_KEEP must be a positive integer")
        }
    } catch (Exception e) {
        errors.add("LATEST_VERSIONS_TO_KEEP must be a valid number")
    }

    try {
        def retentionDays = Integer.parseInt(env.DEV_RETENTION_DAYS ?: '0')
        if (retentionDays <= 0) {
            errors.add("DEV_RETENTION_DAYS must be a positive integer")
        }
    } catch (Exception e) {
        errors.add("DEV_RETENTION_DAYS must be a valid number")
    }

    if (errors.size() > 0) {
        echo "[CLEANUP] ❌ Configuration validation failed:"
        errors.each { error ->
            echo "[CLEANUP] - ${error}"
        }
        return false
    }

    echo "[CLEANUP] ✅ Configuration validation passed"
    echo "[CLEANUP] - Registry: ${env.DOCKER_REGISTRY}"
    echo "[CLEANUP] - Repository: ${env.DOCKER_REPO}"
    echo "[CLEANUP] - Latest path: ${env.DOCKER_LATEST_PATH}"
    echo "[CLEANUP] - Dev path: ${env.DOCKER_DEV_PATH}"
    echo "[CLEANUP] - Keep versions: ${env.LATEST_VERSIONS_TO_KEEP}"
    echo "[CLEANUP] - Retention days: ${env.DEV_RETENTION_DAYS}"

    return true
}

// Test Artifactory connectivity
def testArtifactoryConnectivity() {
    echo "[CLEANUP] Testing Artifactory connectivity..."

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            def testUrl = "https://${env.DOCKER_REGISTRY}/artifactory/api/system/ping"
            def result = makeHttpCall(testUrl, 'GET', 1)

            if (result.success) {
                echo "[CLEANUP] ✅ Artifactory connectivity test passed"
                return true
            } else {
                echo "[CLEANUP] ❌ Artifactory connectivity test failed: ${result.error}"
                return false
            }
        } catch (Exception e) {
            echo "[CLEANUP] ❌ Artifactory connectivity test exception: ${e.message}"
            return false
        }
    }
}

// Comprehensive cleanup test (dry-run mode recommended)
def runCleanupTest() {
    echo "[CLEANUP] Running comprehensive cleanup test..."
    echo "[CLEANUP] This will test all cleanup functions in dry-run mode"

    def testResults = [
        configValid: false,
        connectivityOk: false,
        branchDetectionOk: false,
        devCleanupOk: false,
        latestCleanupOk: false,
        metadataCleanupOk: false
    ]

    try {
        // Test 1: Configuration validation
        testResults.configValid = validateCleanupConfig()

        // Test 2: Connectivity test
        testResults.connectivityOk = testArtifactoryConnectivity()

        // Test 3: Branch detection
        echo "\n[CLEANUP] Testing Git branch detection..."
        def branchResult = getActiveBranches()
        testResults.branchDetectionOk = branchResult.success
        if (branchResult.success) {
            echo "[CLEANUP] ✅ Branch detection test passed: ${branchResult.branches.size()} branches found"
        } else {
            echo "[CLEANUP] ❌ Branch detection test failed: ${branchResult.error}"
        }

        // Test 4-6: Cleanup functions (only if previous tests pass)
        if (testResults.configValid && testResults.connectivityOk) {
            // Force dry-run mode for testing
            def originalDryRun = params.DRY_RUN_CLEANUP
            params.DRY_RUN_CLEANUP = true

            try {
                echo "\n[CLEANUP] Testing docker-dev cleanup (dry-run)..."
                cleanupDevImages()
                testResults.devCleanupOk = true
                echo "[CLEANUP] ✅ Docker-dev cleanup test passed"
            } catch (Exception e) {
                echo "[CLEANUP] ❌ Docker-dev cleanup test failed: ${e.message}"
            }

            try {
                echo "\n[CLEANUP] Testing docker-latest cleanup (dry-run)..."
                cleanupLatestImages()
                testResults.latestCleanupOk = true
                echo "[CLEANUP] ✅ Docker-latest cleanup test passed"
            } catch (Exception e) {
                echo "[CLEANUP] ❌ Docker-latest cleanup test failed: ${e.message}"
            }

            try {
                echo "\n[CLEANUP] Testing metadata cleanup (dry-run)..."
                cleanupTempManifests()
                testResults.metadataCleanupOk = true
                echo "[CLEANUP] ✅ Metadata cleanup test passed"
            } catch (Exception e) {
                echo "[CLEANUP] ❌ Metadata cleanup test failed: ${e.message}"
            }

            // Restore original dry-run setting
            params.DRY_RUN_CLEANUP = originalDryRun
        }

        // Test summary
        echo "\n[CLEANUP] Test Results Summary:"
        echo "[CLEANUP] - Configuration Valid: ${testResults.configValid ? '✅' : '❌'}"
        echo "[CLEANUP] - Connectivity OK: ${testResults.connectivityOk ? '✅' : '❌'}"
        echo "[CLEANUP] - Branch Detection OK: ${testResults.branchDetectionOk ? '✅' : '❌'}"
        echo "[CLEANUP] - Dev Cleanup OK: ${testResults.devCleanupOk ? '✅' : '❌'}"
        echo "[CLEANUP] - Latest Cleanup OK: ${testResults.latestCleanupOk ? '✅' : '❌'}"
        echo "[CLEANUP] - Metadata Cleanup OK: ${testResults.metadataCleanupOk ? '✅' : '❌'}"

        def passedTests = testResults.values().count { it == true }
        def totalTests = testResults.size()

        echo "[CLEANUP] Overall Test Result: ${passedTests}/${totalTests} tests passed"

        return passedTests == totalTests

    } catch (Exception e) {
        echo "[CLEANUP] ❌ Cleanup test suite failed: ${e.message}"
        return false
    }
}

// ================================================================================
// ENHANCED ARTIFACTORY API HELPER FUNCTIONS
// ================================================================================

// Get list of folders/files from Artifactory path
def getArtifactoryFolders(artifactoryPath, maxRetries = 3) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/api/storage/${env.DOCKER_REPO}/${artifactoryPath}"
    def result = makeHttpCall(url, 'GET', maxRetries)

    if (result.success) {
        try {
            def jsonResponse = readJSON text: result.response
            def folders = []

            if (jsonResponse.children) {
                jsonResponse.children.each { child ->
                    if (child.folder) {
                        folders.add(child.uri.replaceAll('^/', ''))
                    }
                }
            }

            return [success: true, folders: folders]
        } catch (Exception e) {
            return [success: false, error: "Failed to parse JSON response: ${e.message}"]
        }
    } else {
        return [success: false, error: result.error]
    }
}

// Get file information from Artifactory
def getArtifactoryFileInfo(artifactoryPath, maxRetries = 3) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/api/storage/${env.DOCKER_REPO}/${artifactoryPath}"
    def result = makeHttpCall(url, 'GET', maxRetries)

    if (result.success) {
        try {
            def jsonResponse = readJSON text: result.response
            return [
                success: true,
                created: jsonResponse.created ?: '',
                lastModified: jsonResponse.lastModified ?: '',
                size: jsonResponse.size ?: 0
            ]
        } catch (Exception e) {
            return [success: false, error: "Failed to parse file info: ${e.message}"]
        }
    } else {
        return [success: false, error: result.error]
    }
}

// Delete path from Artifactory (file or folder)
def deleteArtifactoryPath(artifactoryPath, recursive = false, maxRetries = 3) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/${env.DOCKER_REPO}/${artifactoryPath}"
    if (recursive) {
        url += "?recursive=1"
    }

    echo "    🗑️ Attempting to delete: ${artifactoryPath}"
    echo "    🌐 DELETE URL: ${url}"

    def result = makeHttpCall(url, 'DELETE', maxRetries)
    return result
}

// Check if path exists in Artifactory before deletion
def checkArtifactoryPathExists(artifactoryPath, maxRetries = 1) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/api/storage/${env.DOCKER_REPO}/${artifactoryPath}"
    def result = makeHttpCall(url, 'GET', maxRetries)

    if (result.success) {
        return [exists: true, info: result.response]
    } else if (result.httpStatus == '404') {
        return [exists: false, info: "Path not found"]
    } else {
        return [exists: false, info: "Error checking path: ${result.error}"]
    }
}

// Get list of Docker tags for an application
def getDockerTags(appName, repositoryPath, maxRetries = 3) {
    def url = "https://${env.DOCKER_REGISTRY}/artifactory/api/storage/${env.DOCKER_REPO}/${repositoryPath}/${appName}"
    def result = makeHttpCall(url, 'GET', maxRetries)

    if (result.success) {
        try {
            def jsonResponse = readJSON text: result.response
            def tags = []

            if (jsonResponse.children) {
                jsonResponse.children.each { child ->
                    if (child.folder) {
                        def tagName = child.uri.replaceAll('^/', '')
                        // Skip manifest and sha256 folders
                        if (!tagName.startsWith('sha256:') && tagName != 'manifests' && tagName != '_uploads') {
                            tags.add(tagName)
                        }
                    }
                }
            }

            return [success: true, tags: tags]
        } catch (Exception e) {
            return [success: false, error: "Failed to parse tags: ${e.message}"]
        }
    } else {
        return [success: false, error: result.error]
    }
}

// Get list of active Git branches (both local and remote)
def getActiveBranches() {
    try {
        echo "    🔍 Detecting active Git branches..."
        echo "    Debug: WORKSPACE = ${env.WORKSPACE}"
        echo "    Debug: GIT_BRANCH_NAME = ${env.GIT_BRANCH_NAME}"
        echo "    Debug: BUILD_NUMBER = ${env.BUILD_NUMBER}"

        def activeBranches = [] as Set

        // Method 1: Use Jenkins environment variables first
        try {
            if (env.GIT_BRANCH_NAME && env.GIT_BRANCH_NAME != 'unknown') {
                activeBranches.add(env.GIT_BRANCH_NAME)
                echo "    📋 Added current branch from Jenkins env: ${env.GIT_BRANCH_NAME}"
            }
        } catch (Exception e) {
            echo "    ⚠ Could not get branch from Jenkins env: ${e.message}"
        }

        // Method 2: Try Git commands with better error handling
        try {
            echo "    🔍 Attempting Git branch detection..."
            echo "    Working directory: ${env.WORKSPACE}"

            // Check if we're in a Git repository
            def gitCheck = bat(
                script: '@git status --porcelain 2>nul',
                returnStatus: true
            )

            if (gitCheck == 0) {
                echo "    ✅ Git repository detected"

                // Get remote branches
                def remoteBranches = bat(
                    script: '@git branch -r 2>nul',
                    returnStdout: true
                ).trim()

                if (remoteBranches && remoteBranches != '') {
                    remoteBranches.split('\r?\n').each { branch ->
                        if (branch && branch.trim()) {
                            def cleanBranch = branch.trim()
                            // Remove origin/ prefix if present
                            if (cleanBranch.startsWith('origin/')) {
                                cleanBranch = cleanBranch.replaceAll('^origin/', '')
                            }
                            // Skip HEAD references
                            if (!cleanBranch.contains('HEAD') && cleanBranch != '' && !cleanBranch.contains('->')) {
                                activeBranches.add(cleanBranch)
                            }
                        }
                    }
                    echo "    📋 Found ${activeBranches.size()} remote branches via Git"
                }

                // Get current branch as backup
                if (activeBranches.size() == 0) {
                    def currentBranch = bat(
                        script: '@git rev-parse --abbrev-ref HEAD 2>nul',
                        returnStdout: true
                    ).trim()

                    if (currentBranch && currentBranch != 'HEAD' && currentBranch != '') {
                        activeBranches.add(currentBranch)
                        echo "    📋 Added current branch: ${currentBranch}"
                    }
                }
            } else {
                echo "    ⚠ Not in a Git repository or Git not available"
            }
        } catch (Exception e) {
            echo "    ⚠ Git command failed: ${e.message}"
        }

        // Method 3: Use SCM information if available
        if (activeBranches.size() == 0) {
            try {
                if (scm && scm.branches) {
                    scm.branches.each { branch ->
                        def branchName = branch.name
                        if (branchName.startsWith('*/')) {
                            branchName = branchName.substring(2)
                        }
                        if (branchName && branchName != '') {
                            activeBranches.add(branchName)
                        }
                    }
                    echo "    📋 Found ${activeBranches.size()} branches from SCM config"
                }
            } catch (Exception e) {
                echo "    ⚠ Could not get branches from SCM: ${e.message}"
            }
        }

        // Method 4: Last resort - add main/master and current branch if nothing else works
        if (activeBranches.size() == 0) {
            echo "    ⚠ No branches detected, adding fallback branches"
            activeBranches.add('main')
            activeBranches.add('master')

            // Also add the current branch name from Jenkins if available
            if (env.GIT_BRANCH_NAME && env.GIT_BRANCH_NAME != 'unknown') {
                activeBranches.add(env.GIT_BRANCH_NAME)
            }
        }

        // Convert Set to List and sort
        def branchList = activeBranches.toList().sort()

        echo "    ✅ Active branches detected: ${branchList.join(', ')}"
        return [success: true, branches: branchList]

    } catch (Exception e) {
        echo "    ❌ Error detecting Git branches: ${e.message}"
        return [success: false, error: e.message, branches: []]
    }
}

// ================================================================================
// CLEANUP FUNCTIONS
// ================================================================================

// Cleanup docker-latest repository (keep latest N versions per app)
def cleanupLatestImages() {
    echo "[CLEANUP] Starting docker-latest cleanup..."
    echo "[CLEANUP] Strategy: Keep latest ${env.LATEST_VERSIONS_TO_KEEP} versions per app"
    echo "[CLEANUP] Repository: ${env.DOCKER_LATEST_PATH}"

    if (params.DRY_RUN_CLEANUP) {
        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions will be performed"
    }

    def totalDeleted = 0
    def totalApps = 0

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            // Step 1: Get Docker images using AQL (more efficient)
            echo "\n[CLEANUP] Step 1: Getting Docker images from ${env.DOCKER_LATEST_PATH} using AQL..."
            def imagesResult = getDockerImagesAQL(env.DOCKER_LATEST_PATH)

            if (!imagesResult.success) {
                echo "[CLEANUP] ❌ Could not get Docker images: ${imagesResult.error}"
                return
            }

            def apps = imagesResult.images.keySet()
            totalApps = apps.size()
            echo "[CLEANUP] Found ${totalApps} applications: ${apps.join(', ')}"

            if (totalApps == 0) {
                echo "[CLEANUP] No applications found in ${env.DOCKER_LATEST_PATH}"
                return
            }

            // Step 2: Process each application
            apps.each { app ->
                echo "\n[CLEANUP] Processing app: ${app}"

                def appImages = imagesResult.images[app]
                def allTags = appImages.collect { it.tag }
                echo "[CLEANUP] Found ${allTags.size()} versions: ${allTags.join(', ')}"

                if (allTags.size() <= Integer.parseInt(env.LATEST_VERSIONS_TO_KEEP)) {
                    echo "[CLEANUP] ✅ ${app}: Only ${allTags.size()} versions, keeping all"
                    return
                }

                // Sort versions (semantic version aware)
                def sortedTags = sortVersionTags(allTags)
                def versionsToKeep = Integer.parseInt(env.LATEST_VERSIONS_TO_KEEP)
                def versionsToDelete = sortedTags.drop(versionsToKeep)

                echo "[CLEANUP] Keeping latest ${versionsToKeep} versions: ${sortedTags.take(versionsToKeep).join(', ')}"
                echo "[CLEANUP] Will delete ${versionsToDelete.size()} old versions: ${versionsToDelete.join(', ')}"

                // Delete old versions
                versionsToDelete.each { version ->
                    if (params.DRY_RUN_CLEANUP) {
                        echo "[CLEANUP] 🧪 [DRY RUN] Would delete ${app}:${version}"
                    } else {
                        echo "[CLEANUP] Deleting ${app}:${version}..."
                        def deleteResult = deleteArtifactoryPath("${env.DOCKER_LATEST_PATH}/${app}/${version}", true)

                        if (deleteResult.success) {
                            echo "[CLEANUP] ✅ Deleted ${app}:${version}"
                            totalDeleted++

                            // Also delete corresponding build manifest
                            def manifestPath = "${env.BUILD_MANIFESTS_PATH}/${app}/${version}.json"
                            def manifestDeleteResult = deleteArtifactoryPath(manifestPath)
                            if (manifestDeleteResult.success) {
                                echo "[CLEANUP] ✅ Deleted manifest: ${manifestPath}"
                            } else {
                                echo "[CLEANUP] ⚠ Could not delete manifest ${manifestPath}: ${manifestDeleteResult.error}"
                            }
                        } else {
                            echo "[CLEANUP] ❌ Failed to delete ${app}:${version}: ${deleteResult.error}"
                        }
                    }
                }
            }

            // Summary
            echo "\n[CLEANUP] Docker-latest cleanup summary:"
            echo "[CLEANUP] Applications processed: ${totalApps}"
            if (params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN - No actual deletions performed"
            } else {
                echo "[CLEANUP] Versions deleted: ${totalDeleted}"
            }

        } catch (Exception e) {
            echo "[CLEANUP] ❌ Error during docker-latest cleanup: ${e.message}"
            throw e
        }
    }
}

// Sort version tags (semantic version aware, latest first)
def sortVersionTags(tags) {
    try {
        return tags.sort { a, b ->
            // Try semantic version comparison first
            def aVersion = parseSemanticVersion(a)
            def bVersion = parseSemanticVersion(b)

            if (aVersion && bVersion) {
                // Compare major.minor.patch
                if (aVersion.major != bVersion.major) {
                    return bVersion.major - aVersion.major
                }
                if (aVersion.minor != bVersion.minor) {
                    return bVersion.minor - aVersion.minor
                }
                if (aVersion.patch != bVersion.patch) {
                    return bVersion.patch - aVersion.patch
                }
                return 0
            } else {
                // Fallback to string comparison (reverse for latest first)
                return b.compareTo(a)
            }
        }
    } catch (Exception e) {
        echo "[CLEANUP] Warning: Could not sort versions semantically, using string sort: ${e.message}"
        return tags.sort().reverse()
    }
}

// Parse semantic version (X.Y.Z format)
def parseSemanticVersion(version) {
    try {
        def matcher = version =~ /^(\d+)\.(\d+)\.(\d+)$/
        if (matcher.matches()) {
            return [
                major: Integer.parseInt(matcher[0][1]),
                minor: Integer.parseInt(matcher[0][2]),
                patch: Integer.parseInt(matcher[0][3])
            ]
        }
        return null
    } catch (Exception e) {
        return null
    }
}

// Cleanup docker-dev repository (remove builds from deleted/merged branches)
def cleanupDevImages() {
    echo "[CLEANUP] Starting docker-dev cleanup..."
    echo "[CLEANUP] Strategy: Remove images from deleted/merged branches + images older than ${env.DEV_RETENTION_DAYS} days"
    echo "[CLEANUP] Repository: ${env.DOCKER_DEV_PATH}"

    if (params.DRY_RUN_CLEANUP) {
        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions will be performed"
    }

    def totalDeleted = 0
    def totalApps = 0
    def orphanedBranches = [] as Set

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            // Step 1: Get list of active Git branches
            echo "\n[CLEANUP] Step 1: Getting active Git branches..."
            def branchResult = getActiveBranches()

            if (!branchResult.success) {
                echo "[CLEANUP] ⚠ Could not get Git branches: ${branchResult.error}"
                echo "[CLEANUP] Continuing with time-based cleanup only..."
            }

            def activeBranches = branchResult.branches ?: []
            echo "[CLEANUP] Active branches (${activeBranches.size()}): ${activeBranches.join(', ')}"

            // Step 2: Get all branch builds from metadata using AQL
            echo "\n[CLEANUP] Step 2: Getting historical branch builds from metadata using AQL..."
            def historicalBranches = [] as Set

            def metadataResult = getMetadataFilesAQL(env.TEMP_BUILDS_PATH)
            if (metadataResult.success) {
                metadataResult.metadata.each { app, files ->
                    echo "[CLEANUP] Checking metadata for app: ${app} (${files.size()} files)"

                    files.each { fileInfo ->
                        // Extract branch name from manifest filename
                        def branchName = extractBranchFromManifest(fileInfo.filename)
                        if (branchName) {
                            historicalBranches.add(branchName)
                        }
                    }
                }
            } else {
                echo "[CLEANUP] ⚠ Could not get metadata files: ${metadataResult.error}"
            }

            echo "[CLEANUP] Historical branches found in metadata (${historicalBranches.size()}): ${historicalBranches.join(', ')}"

            // Step 3: Identify orphaned branches (exist in Artifactory but not in Git)
            orphanedBranches = historicalBranches.findAll { branch ->
                !activeBranches.contains(branch)
            }

            echo "\n[CLEANUP] Step 3: Orphaned branches identified (${orphanedBranches.size()}): ${orphanedBranches.join(', ')}"

            if (orphanedBranches.size() == 0) {
                echo "[CLEANUP] ✅ No orphaned branches found - all builds are from active branches"
            }

            // Step 4: Get Docker dev images using AQL and clean up orphaned branch builds
            echo "\n[CLEANUP] Step 4: Processing Docker dev images using AQL..."
            def devImagesResult = getDockerImagesAQL(env.DOCKER_DEV_PATH)

            if (!devImagesResult.success) {
                echo "[CLEANUP] ❌ Could not get Docker dev images: ${devImagesResult.error}"
                return
            }

            def apps = devImagesResult.images.keySet()
            totalApps = apps.size()
            echo "[CLEANUP] Found ${totalApps} applications: ${apps.join(', ')}"

            if (totalApps == 0) {
                echo "[CLEANUP] No applications found in ${env.DOCKER_DEV_PATH}"
                return
            }

            // Process each application
            apps.each { app ->
                echo "\n[CLEANUP] Processing app: ${app}"

                def appImages = devImagesResult.images[app]
                def allTags = appImages.collect { it.tag }
                echo "[CLEANUP] Found ${allTags.size()} dev builds for ${app}"

                // Identify tags from orphaned branches
                def tagsToDelete = []

                allTags.each { tag ->
                    def tagBranch = extractBranchFromTag(tag)
                    if (tagBranch && orphanedBranches.contains(tagBranch)) {
                        tagsToDelete.add(tag)
                    }
                }

                echo "[CLEANUP] Tags from orphaned branches (${tagsToDelete.size()}): ${tagsToDelete.join(', ')}"

                // Delete orphaned branch builds
                tagsToDelete.each { tag ->
                    if (params.DRY_RUN_CLEANUP) {
                        echo "[CLEANUP] 🧪 [DRY RUN] Would delete ${app}:${tag} (orphaned branch)"
                    } else {
                        echo "[CLEANUP] Deleting ${app}:${tag} (orphaned branch)..."
                        def deleteResult = deleteArtifactoryPath("${env.DOCKER_DEV_PATH}/${app}/${tag}", true)

                        if (deleteResult.success) {
                            echo "[CLEANUP] ✅ Deleted ${app}:${tag}"
                            totalDeleted++
                        } else {
                            echo "[CLEANUP] ❌ Failed to delete ${app}:${tag}: ${deleteResult.error}"
                        }
                    }
                }
            }

            // Summary
            echo "\n[CLEANUP] Docker-dev cleanup summary:"
            echo "[CLEANUP] Applications processed: ${totalApps}"
            echo "[CLEANUP] Orphaned branches found: ${orphanedBranches.size()}"
            if (params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN - No actual deletions performed"
            } else {
                echo "[CLEANUP] Images deleted: ${totalDeleted}"
            }

        } catch (Exception e) {
            echo "[CLEANUP] ❌ Error during docker-dev cleanup: ${e.message}"
            throw e
        }
    }
}

// Extract branch name from manifest filename
def extractBranchFromManifest(manifestFile) {
    try {
        // Remove .json extension
        def baseName = manifestFile.replaceAll('\\.json$', '')

        // Remove -manifest suffix if present
        baseName = baseName.replaceAll('-manifest$', '')

        // Extract branch part (everything before the last dash and 8-character commit hash)
        def matcher = baseName =~ /^(.+)-[a-f0-9]{8}$/
        if (matcher.matches()) {
            return matcher[0][1]
        }

        // Fallback: return the whole basename if pattern doesn't match
        return baseName
    } catch (Exception e) {
        echo "[CLEANUP] Warning: Could not extract branch from manifest ${manifestFile}: ${e.message}"
        return null
    }
}

// Extract branch name from Docker tag
def extractBranchFromTag(tag) {
    try {
        // Docker dev tags format: branch-commit (e.g., feature-login-a1b2c3d4)
        def matcher = tag =~ /^(.+)-[a-f0-9]{8}$/
        if (matcher.matches()) {
            return matcher[0][1]
        }

        // If no commit hash pattern, return the tag as-is
        return tag
    } catch (Exception e) {
        echo "[CLEANUP] Warning: Could not extract branch from tag ${tag}: ${e.message}"
        return null
    }
}

// Cleanup temporary build manifests
def cleanupTempManifests() {
    echo "[CLEANUP] Starting metadata cleanup..."
    echo "[CLEANUP] Strategy: Remove manifests for deleted branches + manifests older than ${env.DEV_RETENTION_DAYS} days"
    echo "[CLEANUP] Metadata path: ${env.TEMP_BUILDS_PATH}"

    if (params.DRY_RUN_CLEANUP) {
        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions will be performed"
    }

    def totalDeleted = 0
    def totalApps = 0

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            // Step 1: Get active Git branches
            echo "\n[CLEANUP] Step 1: Getting active Git branches for metadata cleanup..."
            def branchResult = getActiveBranches()
            def activeBranches = branchResult.branches ?: []
            echo "[CLEANUP] Active branches: ${activeBranches.join(', ')}"

            // If no branches detected and this is dry run, add some test branches for demonstration
            if (activeBranches.size() <= 2 && params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN: Adding test branches for demonstration"
                activeBranches.addAll(['feature-test', 'bugfix-demo', 'develop'])
                echo "[CLEANUP] 🧪 DRY RUN: Extended branches list: ${activeBranches.join(', ')}"
            }

            // If no branches detected and this is dry run, add some test branches for demonstration
            if (activeBranches.size() <= 2 && params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN: Adding test branches for demonstration"
                activeBranches.addAll(['feature-test', 'bugfix-demo', 'develop'])
                echo "[CLEANUP] 🧪 DRY RUN: Extended branches list: ${activeBranches.join(', ')}"
            }

            // Step 2: Get cutoff date for time-based cleanup
            def cutoffDate = ''
            try {
                cutoffDate = bat(
                    script: """
                        @powershell -Command "(Get-Date).AddDays(-${env.DEV_RETENTION_DAYS}).ToString('yyyy-MM-ddTHH:mm:ss')"
                    """,
                    returnStdout: true
                ).trim()
                echo "[CLEANUP] Will delete manifests created before: ${cutoffDate}"
            } catch (Exception e) {
                echo "[CLEANUP] Could not calculate cutoff date: ${e.message}"
                echo "[CLEANUP] Continuing with branch-based cleanup only..."
            }

            // Step 3: Get metadata files using AQL
            echo "\n[CLEANUP] Step 3: Processing metadata files using AQL..."

            // Debug: List what's actually in the metadata path
            if (params.DRY_RUN_CLEANUP) {
                debugListArtifactoryPath(env.TEMP_BUILDS_PATH)
            }

            def metadataResult = getMetadataFilesAQL(env.TEMP_BUILDS_PATH)

            if (!metadataResult.success) {
                echo "[CLEANUP] ❌ Could not get metadata files: ${metadataResult.error}"
                return
            }

            def apps = metadataResult.metadata.keySet()
            totalApps = apps.size()
            echo "[CLEANUP] Found ${totalApps} applications with metadata: ${apps.join(', ')}"

            if (totalApps == 0) {
                echo "[CLEANUP] No metadata found in ${env.TEMP_BUILDS_PATH}"
                return
            }

            // Step 4: Process each application's metadata
            apps.each { app ->
                echo "\n[CLEANUP] Processing metadata for app: ${app}"

                def appMetadata = metadataResult.metadata[app]
                echo "[CLEANUP] Found ${appMetadata.size()} manifest files for ${app}"

                // Process each manifest file
                appMetadata.each { fileInfo ->
                    def shouldDelete = false
                    def deleteReason = ""

                    // Check if manifest is from an orphaned branch
                    def branchName = extractBranchFromManifest(fileInfo.filename)
                    if (branchName && !activeBranches.contains(branchName)) {
                        shouldDelete = true
                        deleteReason = "orphaned branch: ${branchName}"
                    }

                    // Check if manifest is too old (if cutoff date is available)
                    if (!shouldDelete && cutoffDate && fileInfo.created) {
                        if (fileInfo.created < cutoffDate) {
                            shouldDelete = true
                            deleteReason = "older than ${env.DEV_RETENTION_DAYS} days (created: ${fileInfo.created})"
                        }
                    }

                    // Delete if needed
                    if (shouldDelete) {
                        if (params.DRY_RUN_CLEANUP) {
                            echo "[CLEANUP] 🧪 [DRY RUN] Would delete ${fileInfo.fullPath} (${deleteReason})"
                        } else {
                            echo "[CLEANUP] Attempting to delete ${fileInfo.fullPath} (${deleteReason})..."

                            // First check if the file exists
                            def existsCheck = checkArtifactoryPathExists(fileInfo.fullPath)
                            if (!existsCheck.exists) {
                                echo "[CLEANUP] ℹ️ ${fileInfo.fullPath} doesn't exist (${existsCheck.info})"
                                // Still count as "deleted" since the goal is achieved
                                totalDeleted++
                            } else {
                                echo "[CLEANUP] ✅ File exists, proceeding with deletion..."
                                def deleteResult = deleteArtifactoryPath(fileInfo.fullPath)

                                if (deleteResult.success) {
                                    if (deleteResult.alreadyDeleted) {
                                        echo "[CLEANUP] ℹ️ ${fileInfo.fullPath} was already deleted during operation"
                                    } else {
                                        echo "[CLEANUP] ✅ Successfully deleted ${fileInfo.fullPath}"
                                    }
                                    totalDeleted++
                                } else {
                                    echo "[CLEANUP] ❌ Failed to delete ${fileInfo.fullPath}: ${deleteResult.error}"
                                    echo "[CLEANUP] HTTP Status: ${deleteResult.httpStatus}"
                                }
                            }
                        }
                    } else {
                        echo "[CLEANUP] ✅ Keeping ${fileInfo.filename} (active branch or recent)"
                    }
                }
            }

            // Summary
            echo "\n[CLEANUP] Metadata cleanup summary:"
            echo "[CLEANUP] Applications processed: ${totalApps}"
            if (params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN - No actual deletions performed"
            } else {
                echo "[CLEANUP] Manifest files deleted: ${totalDeleted}"
            }

        } catch (Exception e) {
            echo "[CLEANUP] ❌ Error during metadata cleanup: ${e.message}"
            throw e
        }
    }
}

// Debug function to list what's actually in a path
def debugListArtifactoryPath(artifactoryPath) {
    echo "[DEBUG] Listing contents of: ${artifactoryPath}"

    def aqlQuery = """items.find({
    "repo": "${env.DOCKER_REPO}",
    "path": {"\$match": "${artifactoryPath}*"}
}).include("path", "name", "type", "size", "created").limit(20)"""

    def result = executeAQL(aqlQuery)

    if (result.success) {
        echo "[DEBUG] Found ${result.results.size()} items:"
        result.results.each { item ->
            echo "[DEBUG] - ${item.type}: ${item.path}/${item.name} (${item.size} bytes, created: ${item.created})"
        }
    } else {
        echo "[DEBUG] Failed to list contents: ${result.error}"
    }
}

// Additional cleanup functions for specific scenarios
def cleanupSpecificBranch(branchName) {
    echo "[CLEANUP] Cleaning up specific branch: ${branchName}"
    echo "[CLEANUP] This will remove all builds and metadata for branch: ${branchName}"

    if (params.DRY_RUN_CLEANUP) {
        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions will be performed"
    }

    def cleanBranchName = branchName
        .replaceAll('[^a-zA-Z0-9._-]', '-')
        .toLowerCase()

    def totalDeleted = 0

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            // Clean up docker-dev images for this branch
            echo "\n[CLEANUP] Step 1: Cleaning docker-dev images for branch ${branchName}..."
            def appsResult = getArtifactoryFolders(env.DOCKER_DEV_PATH)

            if (appsResult.success) {
                appsResult.folders.each { app ->
                    def tagsResult = getDockerTags(app, env.DOCKER_DEV_PATH)
                    if (tagsResult.success) {
                        def branchTags = tagsResult.tags.findAll { tag ->
                            def tagBranch = extractBranchFromTag(tag)
                            return tagBranch == cleanBranchName
                        }

                        branchTags.each { tag ->
                            if (params.DRY_RUN_CLEANUP) {
                                echo "[CLEANUP] 🧪 [DRY RUN] Would delete ${app}:${tag}"
                            } else {
                                def deleteResult = deleteArtifactoryPath("${env.DOCKER_DEV_PATH}/${app}/${tag}", true)
                                if (deleteResult.success) {
                                    echo "[CLEANUP] ✅ Deleted ${app}:${tag}"
                                    totalDeleted++
                                }
                            }
                        }
                    }
                }
            }

            // Clean up metadata for this branch
            echo "\n[CLEANUP] Step 2: Cleaning metadata for branch ${branchName}..."
            def metadataResult = getArtifactoryFolders(env.TEMP_BUILDS_PATH)

            if (metadataResult.success) {
                metadataResult.folders.each { app ->
                    def manifestsResult = getArtifactoryFolders("${env.TEMP_BUILDS_PATH}/${app}")
                    if (manifestsResult.success) {
                        def branchManifests = manifestsResult.folders.findAll { manifest ->
                            def manifestBranch = extractBranchFromManifest(manifest)
                            return manifestBranch == cleanBranchName
                        }

                        branchManifests.each { manifest ->
                            if (params.DRY_RUN_CLEANUP) {
                                echo "[CLEANUP] 🧪 [DRY RUN] Would delete metadata ${app}/${manifest}"
                            } else {
                                def deleteResult = deleteArtifactoryPath("${env.TEMP_BUILDS_PATH}/${app}/${manifest}")
                                if (deleteResult.success) {
                                    echo "[CLEANUP] ✅ Deleted metadata ${app}/${manifest}"
                                    totalDeleted++
                                }
                            }
                        }
                    }
                }
            }

            echo "\n[CLEANUP] Branch cleanup summary:"
            echo "[CLEANUP] Branch: ${branchName}"
            if (params.DRY_RUN_CLEANUP) {
                echo "[CLEANUP] 🧪 DRY RUN - No actual deletions performed"
            } else {
                echo "[CLEANUP] Items deleted: ${totalDeleted}"
            }

        } catch (Exception e) {
            echo "[CLEANUP] ❌ Error during branch cleanup: ${e.message}"
            throw e
        }
    }
}

// Force delete entire app (emergency function)
def forceDeleteApp(appName) {
    echo "[CLEANUP] EMERGENCY: Force deleting entire app: ${appName}"
    echo "[CLEANUP] ⚠️  WARNING: This will delete ALL versions and metadata for ${appName}"

    if (params.DRY_RUN_CLEANUP) {
        echo "[CLEANUP] 🧪 DRY RUN MODE - No actual deletions will be performed"
        echo "[CLEANUP] 🧪 [DRY RUN] Would delete entire app folder: ${env.DOCKER_DEV_PATH}/${appName}"
        echo "[CLEANUP] 🧪 [DRY RUN] Would delete all metadata: ${env.TEMP_BUILDS_PATH}/${appName}"
        return
    }

    withCredentials([usernamePassword(
        credentialsId: 'artifactory-credentials',
        usernameVariable: 'ARTIFACTORY_USER',
        passwordVariable: 'ARTIFACTORY_PASS'
    )]) {
        try {
            // Delete entire app folder from docker-dev
            echo "[CLEANUP] Deleting app folder: ${env.DOCKER_DEV_PATH}/${appName}"
            def deleteResult = deleteArtifactoryPath("${env.DOCKER_DEV_PATH}/${appName}", true)

            if (deleteResult.success) {
                echo "[CLEANUP] ✅ Deleted app folder: ${env.DOCKER_DEV_PATH}/${appName}"
            } else {
                echo "[CLEANUP] ❌ Failed to delete app folder: ${deleteResult.error}"
            }

            // Delete all metadata for this app
            echo "[CLEANUP] Deleting app metadata: ${env.TEMP_BUILDS_PATH}/${appName}"
            def metadataDeleteResult = deleteArtifactoryPath("${env.TEMP_BUILDS_PATH}/${appName}", true)

            if (metadataDeleteResult.success) {
                echo "[CLEANUP] ✅ Deleted app metadata: ${env.TEMP_BUILDS_PATH}/${appName}"
            } else {
                echo "[CLEANUP] ❌ Failed to delete app metadata: ${metadataDeleteResult.error}"
            }

        } catch (Exception e) {
            echo "[CLEANUP] ❌ Error during force app deletion: ${e.message}"
            throw e
        }
    }
}
